// Copyright 2022 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package deploy.model;

option go_package = "go.chromium.org/luci/deploy/api/modelpb";

import "google/protobuf/timestamp.proto";
import "google/rpc/status.proto";

import "go.chromium.org/luci/deploy/api/modelpb/deployment.proto";


// An inflight or finished actuation of some deployment.
//
// Initiated by BeginActuation RPC and finalized by EndActuation RPC or
// by timeout.
message Actuation {
  // Unique ID of the actuation.
  //
  // Generated by the actuator when it starts an actuation attempt. Can be an
  // arbitrary string under 40 chars (as long as it is sufficiently random).
  //
  // Used to make BeginActuation and EndActuation calls idempotent and to pair
  // them with each other.
  string id = 1;

  // The state of this actuation.
  enum State {
    STATE_UNSPECIFIED = 0;

    EXECUTING = 1;  // the actuation is executing right now
    SUCCEEDED = 2;  // the actuation finished successfully
    FAILED    = 3;  // the actuation failed (perhaps partially)
    EXPIRED   = 4;  // the actuator disappeared before reporting the outcome
  }
  State state = 2;

  // The deployment being actuated.
  Deployment deployment = 3;
  // The actuator that performs the actuation.
  ActuatorInfo actuator = 4;
  // The list of triggers if the actuation attempt was triggered by the backend.
  repeated ActuationTrigger triggers = 5;
  // When the actuation was created.
  google.protobuf.Timestamp created = 6;
  // When the actuation finished (successfully or not).
  google.protobuf.Timestamp finished = 7;
  // When the actuation expires.
  google.protobuf.Timestamp expiry = 8;
  // Error details if the actuation failed or expired.
  google.rpc.Status status = 9;
  // Link to a human-readable actuation log (if available).
  string log_url = 10;
}


// Information about the agent that performs the actuation.
message ActuatorInfo {
  // The RPC identity of the actuator.
  string identity = 1;
  // Buildbucket host hosting the builder.
  string buildbucket = 2;
  // Buildbucket builder running the actuation, as "project/bucket/name".
  string buildbucket_builder = 3;
  // Buildbucket build ID of the build running the actuation.
  int64 buildbucket_build = 4;
  // Scheduler host hosting the job.
  string scheduler = 5;
  // Scheduler job ID that triggered the build, as "project/name".
  string scheduler_job = 6;
  // Scheduler invocation ID that triggered the build.
  int64 scheduler_invocation = 7;
}


// ActuationTrigger is round-tripped through LUCI when triggering actuations.
//
// It is converted to google.protobuf.Struct and used as `properties` in
// scheduler.BuildbucketTrigger when calling Scheduler's EmitTriggers RPC.
message ActuationTrigger {
  // Empty for now.
}


// Describes why an actuation must **not** be attempted.
//
// Multiple assets may refer to a single lock by its ID.
message ActuationLock {
  // Unique global auto-generated ID.
  string id = 1;

  // What kind of lock this is.
  enum Kind {
    KIND_UNSPECIFIED = 0;

    MANUAL    = 1;  // created by an end-user via web UI or API
    ANTISTOMP = 2;  // an automatically created anti-stomp lock
  }
  Kind kind = 2;

  // The state of the lock.
  enum State {
    STATE_UNSPECIFIED = 0;

    ACTIVE   = 1;  // the lock is still active
    DISABLED = 2;  // the lock was explicitly disabled via web UI or API
    EXPIRED  = 3;  // the lock expired
  }
  State state = 3;

  // A short human readable message describing why the lock exists.
  string reason_text = 4;
  // An HTTP URL to the full justification (e.g. a bug or some status page).
  string reason_url = 5;
  // When the lock was created.
  google.protobuf.Timestamp created = 6;
  // When the lock was removed (if it was).
  google.protobuf.Timestamp removed = 7;
  // When the lock expires (if it is).
  google.protobuf.Timestamp expiry = 8;
  // User that created the lock (if any).
  string created_by = 9;
  // User that removed the lock (if any).
  string removed_by = 10;
}


// Defines what the actuator should do with an asset.
message ActuationDecision {
  // What to do with an asset.
  enum Decision {
    DECISION_UNSPECIFIED = 0;

    ACTUATE_STALE = 1;  // the asset appears to be stale and must be actuated
    ACTUATE_FORCE = 2;  // the asset must be actuated even if it is up-to-date

    SKIP_UPTODATE = 3;  // the asset is up-to-date and should not be actuated
    SKIP_DISABLED = 4;  // the actuation is disabled in the config
    SKIP_LOCKED   = 5;  // the actuation of this asset is locked
    SKIP_BROKEN   = 6;  // something is broken, the asset should not be touched
  }
  Decision decision = 1;

  // Error details for SKIP_BROKEN decision.
  google.rpc.Status status = 2;

  // The list of active locks for this asset (if any).
  repeated ActuationLock locks = 3;
}


// Records the decisions made when the actuation was started.
message ActuationDecisions {
  // Per-asset decision whether to proceed with the actuation or to skip it.
  map<string, ActuationDecision> decisions = 1;
}
