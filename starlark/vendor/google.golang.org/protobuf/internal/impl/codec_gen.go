// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style.
// license that can be found in the LICENSE file.

// Code generated by generate-types. DO NOT EDIT.

package impl

import (
	"math"
	"unicode/utf8"

	"google.golang.org/protobuf/internal/encoding/wire"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// sizeBool returns the size of wire encoding a bool pointer as a Bool.
func sizeBool(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Bool()
	return tagsize + wire.SizeVarint(wire.EncodeBool(v))
}

// appendBool wire encodes a bool pointer as a Bool.
func appendBool(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Bool()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeBool(v))
	return b, nil
}

// consumeBool wire decodes a bool pointer as a Bool.
func consumeBool(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Bool() = wire.DecodeBool(v)
	return n, nil
}

var coderBool = pointerCoderFuncs{
	size:      sizeBool,
	marshal:   appendBool,
	unmarshal: consumeBool,
}

// sizeBoolNoZero returns the size of wire encoding a bool pointer as a Bool.
// The zero value is not encoded.
func sizeBoolNoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Bool()
	if v == false {
		return 0
	}
	return tagsize + wire.SizeVarint(wire.EncodeBool(v))
}

// appendBoolNoZero wire encodes a bool pointer as a Bool.
// The zero value is not encoded.
func appendBoolNoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Bool()
	if v == false {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeBool(v))
	return b, nil
}

var coderBoolNoZero = pointerCoderFuncs{
	size:      sizeBoolNoZero,
	marshal:   appendBoolNoZero,
	unmarshal: consumeBool,
}

// sizeBoolPtr returns the size of wire encoding a *bool pointer as a Bool.
// It panics if the pointer is nil.
func sizeBoolPtr(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := **p.BoolPtr()
	return tagsize + wire.SizeVarint(wire.EncodeBool(v))
}

// appendBoolPtr wire encodes a *bool pointer as a Bool.
// It panics if the pointer is nil.
func appendBoolPtr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.BoolPtr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeBool(v))
	return b, nil
}

// consumeBoolPtr wire decodes a *bool pointer as a Bool.
func consumeBoolPtr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.BoolPtr()
	if *vp == nil {
		*vp = new(bool)
	}
	**vp = wire.DecodeBool(v)
	return n, nil
}

var coderBoolPtr = pointerCoderFuncs{
	size:      sizeBoolPtr,
	marshal:   appendBoolPtr,
	unmarshal: consumeBoolPtr,
}

// sizeBoolSlice returns the size of wire encoding a []bool pointer as a repeated Bool.
func sizeBoolSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.BoolSlice()
	for _, v := range s {
		size += tagsize + wire.SizeVarint(wire.EncodeBool(v))
	}
	return size
}

// appendBoolSlice encodes a []bool pointer as a repeated Bool.
func appendBoolSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.BoolSlice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, wire.EncodeBool(v))
	}
	return b, nil
}

// consumeBoolSlice wire decodes a []bool pointer as a repeated Bool.
func consumeBoolSlice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.BoolSlice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, wire.DecodeBool(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, wire.DecodeBool(v))
	return n, nil
}

var coderBoolSlice = pointerCoderFuncs{
	size:      sizeBoolSlice,
	marshal:   appendBoolSlice,
	unmarshal: consumeBoolSlice,
}

// sizeBoolPackedSlice returns the size of wire encoding a []bool pointer as a packed repeated Bool.
func sizeBoolPackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.BoolSlice()
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeBool(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendBoolPackedSlice encodes a []bool pointer as a packed repeated Bool.
func appendBoolPackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.BoolSlice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeBool(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, wire.EncodeBool(v))
	}
	return b, nil
}

var coderBoolPackedSlice = pointerCoderFuncs{
	size:      sizeBoolPackedSlice,
	marshal:   appendBoolPackedSlice,
	unmarshal: consumeBoolSlice,
}

// sizeBoolIface returns the size of wire encoding a bool value as a Bool.
func sizeBoolIface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.(bool)
	return tagsize + wire.SizeVarint(wire.EncodeBool(v))
}

// appendBoolIface encodes a bool value as a Bool.
func appendBoolIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(bool)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeBool(v))
	return b, nil
}

// consumeBoolIface decodes a bool value as a Bool.
func consumeBoolIface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return wire.DecodeBool(v), n, nil
}

var coderBoolIface = ifaceCoderFuncs{
	size:      sizeBoolIface,
	marshal:   appendBoolIface,
	unmarshal: consumeBoolIface,
}

// sizeBoolSliceIface returns the size of wire encoding a []bool value as a repeated Bool.
func sizeBoolSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]bool)
	for _, v := range s {
		size += tagsize + wire.SizeVarint(wire.EncodeBool(v))
	}
	return size
}

// appendBoolSliceIface encodes a []bool value as a repeated Bool.
func appendBoolSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]bool)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, wire.EncodeBool(v))
	}
	return b, nil
}

// consumeBoolSliceIface wire decodes a []bool value as a repeated Bool.
func consumeBoolSliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]bool)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, wire.DecodeBool(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, wire.DecodeBool(v))
	return ival, n, nil
}

var coderBoolSliceIface = ifaceCoderFuncs{
	size:      sizeBoolSliceIface,
	marshal:   appendBoolSliceIface,
	unmarshal: consumeBoolSliceIface,
}

// sizeBoolPackedSliceIface returns the size of wire encoding a []bool value as a packed repeated Bool.
func sizeBoolPackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]bool)
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeBool(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendBoolPackedSliceIface encodes a []bool value as a packed repeated Bool.
func appendBoolPackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]bool)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeBool(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, wire.EncodeBool(v))
	}
	return b, nil
}

var coderBoolPackedSliceIface = ifaceCoderFuncs{
	size:      sizeBoolPackedSliceIface,
	marshal:   appendBoolPackedSliceIface,
	unmarshal: consumeBoolSliceIface,
}

// sizeInt32 returns the size of wire encoding a int32 pointer as a Int32.
func sizeInt32(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int32()
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendInt32 wire encodes a int32 pointer as a Int32.
func appendInt32(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int32()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeInt32 wire decodes a int32 pointer as a Int32.
func consumeInt32(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Int32() = int32(v)
	return n, nil
}

var coderInt32 = pointerCoderFuncs{
	size:      sizeInt32,
	marshal:   appendInt32,
	unmarshal: consumeInt32,
}

// sizeInt32NoZero returns the size of wire encoding a int32 pointer as a Int32.
// The zero value is not encoded.
func sizeInt32NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int32()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendInt32NoZero wire encodes a int32 pointer as a Int32.
// The zero value is not encoded.
func appendInt32NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int32()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

var coderInt32NoZero = pointerCoderFuncs{
	size:      sizeInt32NoZero,
	marshal:   appendInt32NoZero,
	unmarshal: consumeInt32,
}

// sizeInt32Ptr returns the size of wire encoding a *int32 pointer as a Int32.
// It panics if the pointer is nil.
func sizeInt32Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := **p.Int32Ptr()
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendInt32Ptr wire encodes a *int32 pointer as a Int32.
// It panics if the pointer is nil.
func appendInt32Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Int32Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeInt32Ptr wire decodes a *int32 pointer as a Int32.
func consumeInt32Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Int32Ptr()
	if *vp == nil {
		*vp = new(int32)
	}
	**vp = int32(v)
	return n, nil
}

var coderInt32Ptr = pointerCoderFuncs{
	size:      sizeInt32Ptr,
	marshal:   appendInt32Ptr,
	unmarshal: consumeInt32Ptr,
}

// sizeInt32Slice returns the size of wire encoding a []int32 pointer as a repeated Int32.
func sizeInt32Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int32Slice()
	for _, v := range s {
		size += tagsize + wire.SizeVarint(uint64(v))
	}
	return size
}

// appendInt32Slice encodes a []int32 pointer as a repeated Int32.
func appendInt32Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int32Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

// consumeInt32Slice wire decodes a []int32 pointer as a repeated Int32.
func consumeInt32Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Int32Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, int32(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, int32(v))
	return n, nil
}

var coderInt32Slice = pointerCoderFuncs{
	size:      sizeInt32Slice,
	marshal:   appendInt32Slice,
	unmarshal: consumeInt32Slice,
}

// sizeInt32PackedSlice returns the size of wire encoding a []int32 pointer as a packed repeated Int32.
func sizeInt32PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int32Slice()
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendInt32PackedSlice encodes a []int32 pointer as a packed repeated Int32.
func appendInt32PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int32Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

var coderInt32PackedSlice = pointerCoderFuncs{
	size:      sizeInt32PackedSlice,
	marshal:   appendInt32PackedSlice,
	unmarshal: consumeInt32Slice,
}

// sizeInt32Iface returns the size of wire encoding a int32 value as a Int32.
func sizeInt32Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.(int32)
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendInt32Iface encodes a int32 value as a Int32.
func appendInt32Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(int32)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeInt32Iface decodes a int32 value as a Int32.
func consumeInt32Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return int32(v), n, nil
}

var coderInt32Iface = ifaceCoderFuncs{
	size:      sizeInt32Iface,
	marshal:   appendInt32Iface,
	unmarshal: consumeInt32Iface,
}

// sizeInt32SliceIface returns the size of wire encoding a []int32 value as a repeated Int32.
func sizeInt32SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int32)
	for _, v := range s {
		size += tagsize + wire.SizeVarint(uint64(v))
	}
	return size
}

// appendInt32SliceIface encodes a []int32 value as a repeated Int32.
func appendInt32SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int32)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

// consumeInt32SliceIface wire decodes a []int32 value as a repeated Int32.
func consumeInt32SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]int32)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, int32(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, int32(v))
	return ival, n, nil
}

var coderInt32SliceIface = ifaceCoderFuncs{
	size:      sizeInt32SliceIface,
	marshal:   appendInt32SliceIface,
	unmarshal: consumeInt32SliceIface,
}

// sizeInt32PackedSliceIface returns the size of wire encoding a []int32 value as a packed repeated Int32.
func sizeInt32PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int32)
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendInt32PackedSliceIface encodes a []int32 value as a packed repeated Int32.
func appendInt32PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int32)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

var coderInt32PackedSliceIface = ifaceCoderFuncs{
	size:      sizeInt32PackedSliceIface,
	marshal:   appendInt32PackedSliceIface,
	unmarshal: consumeInt32SliceIface,
}

// sizeSint32 returns the size of wire encoding a int32 pointer as a Sint32.
func sizeSint32(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int32()
	return tagsize + wire.SizeVarint(wire.EncodeZigZag(int64(v)))
}

// appendSint32 wire encodes a int32 pointer as a Sint32.
func appendSint32(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int32()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeZigZag(int64(v)))
	return b, nil
}

// consumeSint32 wire decodes a int32 pointer as a Sint32.
func consumeSint32(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Int32() = int32(wire.DecodeZigZag(v & math.MaxUint32))
	return n, nil
}

var coderSint32 = pointerCoderFuncs{
	size:      sizeSint32,
	marshal:   appendSint32,
	unmarshal: consumeSint32,
}

// sizeSint32NoZero returns the size of wire encoding a int32 pointer as a Sint32.
// The zero value is not encoded.
func sizeSint32NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int32()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeVarint(wire.EncodeZigZag(int64(v)))
}

// appendSint32NoZero wire encodes a int32 pointer as a Sint32.
// The zero value is not encoded.
func appendSint32NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int32()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeZigZag(int64(v)))
	return b, nil
}

var coderSint32NoZero = pointerCoderFuncs{
	size:      sizeSint32NoZero,
	marshal:   appendSint32NoZero,
	unmarshal: consumeSint32,
}

// sizeSint32Ptr returns the size of wire encoding a *int32 pointer as a Sint32.
// It panics if the pointer is nil.
func sizeSint32Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := **p.Int32Ptr()
	return tagsize + wire.SizeVarint(wire.EncodeZigZag(int64(v)))
}

// appendSint32Ptr wire encodes a *int32 pointer as a Sint32.
// It panics if the pointer is nil.
func appendSint32Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Int32Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeZigZag(int64(v)))
	return b, nil
}

// consumeSint32Ptr wire decodes a *int32 pointer as a Sint32.
func consumeSint32Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Int32Ptr()
	if *vp == nil {
		*vp = new(int32)
	}
	**vp = int32(wire.DecodeZigZag(v & math.MaxUint32))
	return n, nil
}

var coderSint32Ptr = pointerCoderFuncs{
	size:      sizeSint32Ptr,
	marshal:   appendSint32Ptr,
	unmarshal: consumeSint32Ptr,
}

// sizeSint32Slice returns the size of wire encoding a []int32 pointer as a repeated Sint32.
func sizeSint32Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int32Slice()
	for _, v := range s {
		size += tagsize + wire.SizeVarint(wire.EncodeZigZag(int64(v)))
	}
	return size
}

// appendSint32Slice encodes a []int32 pointer as a repeated Sint32.
func appendSint32Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int32Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, wire.EncodeZigZag(int64(v)))
	}
	return b, nil
}

// consumeSint32Slice wire decodes a []int32 pointer as a repeated Sint32.
func consumeSint32Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Int32Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, int32(wire.DecodeZigZag(v&math.MaxUint32)))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, int32(wire.DecodeZigZag(v&math.MaxUint32)))
	return n, nil
}

var coderSint32Slice = pointerCoderFuncs{
	size:      sizeSint32Slice,
	marshal:   appendSint32Slice,
	unmarshal: consumeSint32Slice,
}

// sizeSint32PackedSlice returns the size of wire encoding a []int32 pointer as a packed repeated Sint32.
func sizeSint32PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int32Slice()
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeZigZag(int64(v)))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendSint32PackedSlice encodes a []int32 pointer as a packed repeated Sint32.
func appendSint32PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int32Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeZigZag(int64(v)))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, wire.EncodeZigZag(int64(v)))
	}
	return b, nil
}

var coderSint32PackedSlice = pointerCoderFuncs{
	size:      sizeSint32PackedSlice,
	marshal:   appendSint32PackedSlice,
	unmarshal: consumeSint32Slice,
}

// sizeSint32Iface returns the size of wire encoding a int32 value as a Sint32.
func sizeSint32Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.(int32)
	return tagsize + wire.SizeVarint(wire.EncodeZigZag(int64(v)))
}

// appendSint32Iface encodes a int32 value as a Sint32.
func appendSint32Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(int32)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeZigZag(int64(v)))
	return b, nil
}

// consumeSint32Iface decodes a int32 value as a Sint32.
func consumeSint32Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return int32(wire.DecodeZigZag(v & math.MaxUint32)), n, nil
}

var coderSint32Iface = ifaceCoderFuncs{
	size:      sizeSint32Iface,
	marshal:   appendSint32Iface,
	unmarshal: consumeSint32Iface,
}

// sizeSint32SliceIface returns the size of wire encoding a []int32 value as a repeated Sint32.
func sizeSint32SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int32)
	for _, v := range s {
		size += tagsize + wire.SizeVarint(wire.EncodeZigZag(int64(v)))
	}
	return size
}

// appendSint32SliceIface encodes a []int32 value as a repeated Sint32.
func appendSint32SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int32)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, wire.EncodeZigZag(int64(v)))
	}
	return b, nil
}

// consumeSint32SliceIface wire decodes a []int32 value as a repeated Sint32.
func consumeSint32SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]int32)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, int32(wire.DecodeZigZag(v&math.MaxUint32)))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, int32(wire.DecodeZigZag(v&math.MaxUint32)))
	return ival, n, nil
}

var coderSint32SliceIface = ifaceCoderFuncs{
	size:      sizeSint32SliceIface,
	marshal:   appendSint32SliceIface,
	unmarshal: consumeSint32SliceIface,
}

// sizeSint32PackedSliceIface returns the size of wire encoding a []int32 value as a packed repeated Sint32.
func sizeSint32PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int32)
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeZigZag(int64(v)))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendSint32PackedSliceIface encodes a []int32 value as a packed repeated Sint32.
func appendSint32PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int32)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeZigZag(int64(v)))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, wire.EncodeZigZag(int64(v)))
	}
	return b, nil
}

var coderSint32PackedSliceIface = ifaceCoderFuncs{
	size:      sizeSint32PackedSliceIface,
	marshal:   appendSint32PackedSliceIface,
	unmarshal: consumeSint32SliceIface,
}

// sizeUint32 returns the size of wire encoding a uint32 pointer as a Uint32.
func sizeUint32(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Uint32()
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendUint32 wire encodes a uint32 pointer as a Uint32.
func appendUint32(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Uint32()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeUint32 wire decodes a uint32 pointer as a Uint32.
func consumeUint32(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Uint32() = uint32(v)
	return n, nil
}

var coderUint32 = pointerCoderFuncs{
	size:      sizeUint32,
	marshal:   appendUint32,
	unmarshal: consumeUint32,
}

// sizeUint32NoZero returns the size of wire encoding a uint32 pointer as a Uint32.
// The zero value is not encoded.
func sizeUint32NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Uint32()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendUint32NoZero wire encodes a uint32 pointer as a Uint32.
// The zero value is not encoded.
func appendUint32NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Uint32()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

var coderUint32NoZero = pointerCoderFuncs{
	size:      sizeUint32NoZero,
	marshal:   appendUint32NoZero,
	unmarshal: consumeUint32,
}

// sizeUint32Ptr returns the size of wire encoding a *uint32 pointer as a Uint32.
// It panics if the pointer is nil.
func sizeUint32Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := **p.Uint32Ptr()
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendUint32Ptr wire encodes a *uint32 pointer as a Uint32.
// It panics if the pointer is nil.
func appendUint32Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Uint32Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeUint32Ptr wire decodes a *uint32 pointer as a Uint32.
func consumeUint32Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Uint32Ptr()
	if *vp == nil {
		*vp = new(uint32)
	}
	**vp = uint32(v)
	return n, nil
}

var coderUint32Ptr = pointerCoderFuncs{
	size:      sizeUint32Ptr,
	marshal:   appendUint32Ptr,
	unmarshal: consumeUint32Ptr,
}

// sizeUint32Slice returns the size of wire encoding a []uint32 pointer as a repeated Uint32.
func sizeUint32Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Uint32Slice()
	for _, v := range s {
		size += tagsize + wire.SizeVarint(uint64(v))
	}
	return size
}

// appendUint32Slice encodes a []uint32 pointer as a repeated Uint32.
func appendUint32Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Uint32Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

// consumeUint32Slice wire decodes a []uint32 pointer as a repeated Uint32.
func consumeUint32Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Uint32Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, uint32(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, uint32(v))
	return n, nil
}

var coderUint32Slice = pointerCoderFuncs{
	size:      sizeUint32Slice,
	marshal:   appendUint32Slice,
	unmarshal: consumeUint32Slice,
}

// sizeUint32PackedSlice returns the size of wire encoding a []uint32 pointer as a packed repeated Uint32.
func sizeUint32PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Uint32Slice()
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendUint32PackedSlice encodes a []uint32 pointer as a packed repeated Uint32.
func appendUint32PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Uint32Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

var coderUint32PackedSlice = pointerCoderFuncs{
	size:      sizeUint32PackedSlice,
	marshal:   appendUint32PackedSlice,
	unmarshal: consumeUint32Slice,
}

// sizeUint32Iface returns the size of wire encoding a uint32 value as a Uint32.
func sizeUint32Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.(uint32)
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendUint32Iface encodes a uint32 value as a Uint32.
func appendUint32Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(uint32)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeUint32Iface decodes a uint32 value as a Uint32.
func consumeUint32Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return uint32(v), n, nil
}

var coderUint32Iface = ifaceCoderFuncs{
	size:      sizeUint32Iface,
	marshal:   appendUint32Iface,
	unmarshal: consumeUint32Iface,
}

// sizeUint32SliceIface returns the size of wire encoding a []uint32 value as a repeated Uint32.
func sizeUint32SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]uint32)
	for _, v := range s {
		size += tagsize + wire.SizeVarint(uint64(v))
	}
	return size
}

// appendUint32SliceIface encodes a []uint32 value as a repeated Uint32.
func appendUint32SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]uint32)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

// consumeUint32SliceIface wire decodes a []uint32 value as a repeated Uint32.
func consumeUint32SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]uint32)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, uint32(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, uint32(v))
	return ival, n, nil
}

var coderUint32SliceIface = ifaceCoderFuncs{
	size:      sizeUint32SliceIface,
	marshal:   appendUint32SliceIface,
	unmarshal: consumeUint32SliceIface,
}

// sizeUint32PackedSliceIface returns the size of wire encoding a []uint32 value as a packed repeated Uint32.
func sizeUint32PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]uint32)
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendUint32PackedSliceIface encodes a []uint32 value as a packed repeated Uint32.
func appendUint32PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]uint32)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

var coderUint32PackedSliceIface = ifaceCoderFuncs{
	size:      sizeUint32PackedSliceIface,
	marshal:   appendUint32PackedSliceIface,
	unmarshal: consumeUint32SliceIface,
}

// sizeInt64 returns the size of wire encoding a int64 pointer as a Int64.
func sizeInt64(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int64()
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendInt64 wire encodes a int64 pointer as a Int64.
func appendInt64(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int64()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeInt64 wire decodes a int64 pointer as a Int64.
func consumeInt64(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Int64() = int64(v)
	return n, nil
}

var coderInt64 = pointerCoderFuncs{
	size:      sizeInt64,
	marshal:   appendInt64,
	unmarshal: consumeInt64,
}

// sizeInt64NoZero returns the size of wire encoding a int64 pointer as a Int64.
// The zero value is not encoded.
func sizeInt64NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int64()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendInt64NoZero wire encodes a int64 pointer as a Int64.
// The zero value is not encoded.
func appendInt64NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int64()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

var coderInt64NoZero = pointerCoderFuncs{
	size:      sizeInt64NoZero,
	marshal:   appendInt64NoZero,
	unmarshal: consumeInt64,
}

// sizeInt64Ptr returns the size of wire encoding a *int64 pointer as a Int64.
// It panics if the pointer is nil.
func sizeInt64Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := **p.Int64Ptr()
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendInt64Ptr wire encodes a *int64 pointer as a Int64.
// It panics if the pointer is nil.
func appendInt64Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Int64Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeInt64Ptr wire decodes a *int64 pointer as a Int64.
func consumeInt64Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Int64Ptr()
	if *vp == nil {
		*vp = new(int64)
	}
	**vp = int64(v)
	return n, nil
}

var coderInt64Ptr = pointerCoderFuncs{
	size:      sizeInt64Ptr,
	marshal:   appendInt64Ptr,
	unmarshal: consumeInt64Ptr,
}

// sizeInt64Slice returns the size of wire encoding a []int64 pointer as a repeated Int64.
func sizeInt64Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int64Slice()
	for _, v := range s {
		size += tagsize + wire.SizeVarint(uint64(v))
	}
	return size
}

// appendInt64Slice encodes a []int64 pointer as a repeated Int64.
func appendInt64Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int64Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

// consumeInt64Slice wire decodes a []int64 pointer as a repeated Int64.
func consumeInt64Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Int64Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, int64(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, int64(v))
	return n, nil
}

var coderInt64Slice = pointerCoderFuncs{
	size:      sizeInt64Slice,
	marshal:   appendInt64Slice,
	unmarshal: consumeInt64Slice,
}

// sizeInt64PackedSlice returns the size of wire encoding a []int64 pointer as a packed repeated Int64.
func sizeInt64PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int64Slice()
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendInt64PackedSlice encodes a []int64 pointer as a packed repeated Int64.
func appendInt64PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int64Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

var coderInt64PackedSlice = pointerCoderFuncs{
	size:      sizeInt64PackedSlice,
	marshal:   appendInt64PackedSlice,
	unmarshal: consumeInt64Slice,
}

// sizeInt64Iface returns the size of wire encoding a int64 value as a Int64.
func sizeInt64Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.(int64)
	return tagsize + wire.SizeVarint(uint64(v))
}

// appendInt64Iface encodes a int64 value as a Int64.
func appendInt64Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(int64)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, uint64(v))
	return b, nil
}

// consumeInt64Iface decodes a int64 value as a Int64.
func consumeInt64Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return int64(v), n, nil
}

var coderInt64Iface = ifaceCoderFuncs{
	size:      sizeInt64Iface,
	marshal:   appendInt64Iface,
	unmarshal: consumeInt64Iface,
}

// sizeInt64SliceIface returns the size of wire encoding a []int64 value as a repeated Int64.
func sizeInt64SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int64)
	for _, v := range s {
		size += tagsize + wire.SizeVarint(uint64(v))
	}
	return size
}

// appendInt64SliceIface encodes a []int64 value as a repeated Int64.
func appendInt64SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int64)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

// consumeInt64SliceIface wire decodes a []int64 value as a repeated Int64.
func consumeInt64SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]int64)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, int64(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, int64(v))
	return ival, n, nil
}

var coderInt64SliceIface = ifaceCoderFuncs{
	size:      sizeInt64SliceIface,
	marshal:   appendInt64SliceIface,
	unmarshal: consumeInt64SliceIface,
}

// sizeInt64PackedSliceIface returns the size of wire encoding a []int64 value as a packed repeated Int64.
func sizeInt64PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int64)
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendInt64PackedSliceIface encodes a []int64 value as a packed repeated Int64.
func appendInt64PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int64)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(uint64(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, uint64(v))
	}
	return b, nil
}

var coderInt64PackedSliceIface = ifaceCoderFuncs{
	size:      sizeInt64PackedSliceIface,
	marshal:   appendInt64PackedSliceIface,
	unmarshal: consumeInt64SliceIface,
}

// sizeSint64 returns the size of wire encoding a int64 pointer as a Sint64.
func sizeSint64(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int64()
	return tagsize + wire.SizeVarint(wire.EncodeZigZag(v))
}

// appendSint64 wire encodes a int64 pointer as a Sint64.
func appendSint64(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int64()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeZigZag(v))
	return b, nil
}

// consumeSint64 wire decodes a int64 pointer as a Sint64.
func consumeSint64(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Int64() = wire.DecodeZigZag(v)
	return n, nil
}

var coderSint64 = pointerCoderFuncs{
	size:      sizeSint64,
	marshal:   appendSint64,
	unmarshal: consumeSint64,
}

// sizeSint64NoZero returns the size of wire encoding a int64 pointer as a Sint64.
// The zero value is not encoded.
func sizeSint64NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int64()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeVarint(wire.EncodeZigZag(v))
}

// appendSint64NoZero wire encodes a int64 pointer as a Sint64.
// The zero value is not encoded.
func appendSint64NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int64()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeZigZag(v))
	return b, nil
}

var coderSint64NoZero = pointerCoderFuncs{
	size:      sizeSint64NoZero,
	marshal:   appendSint64NoZero,
	unmarshal: consumeSint64,
}

// sizeSint64Ptr returns the size of wire encoding a *int64 pointer as a Sint64.
// It panics if the pointer is nil.
func sizeSint64Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := **p.Int64Ptr()
	return tagsize + wire.SizeVarint(wire.EncodeZigZag(v))
}

// appendSint64Ptr wire encodes a *int64 pointer as a Sint64.
// It panics if the pointer is nil.
func appendSint64Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Int64Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeZigZag(v))
	return b, nil
}

// consumeSint64Ptr wire decodes a *int64 pointer as a Sint64.
func consumeSint64Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Int64Ptr()
	if *vp == nil {
		*vp = new(int64)
	}
	**vp = wire.DecodeZigZag(v)
	return n, nil
}

var coderSint64Ptr = pointerCoderFuncs{
	size:      sizeSint64Ptr,
	marshal:   appendSint64Ptr,
	unmarshal: consumeSint64Ptr,
}

// sizeSint64Slice returns the size of wire encoding a []int64 pointer as a repeated Sint64.
func sizeSint64Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int64Slice()
	for _, v := range s {
		size += tagsize + wire.SizeVarint(wire.EncodeZigZag(v))
	}
	return size
}

// appendSint64Slice encodes a []int64 pointer as a repeated Sint64.
func appendSint64Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int64Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, wire.EncodeZigZag(v))
	}
	return b, nil
}

// consumeSint64Slice wire decodes a []int64 pointer as a repeated Sint64.
func consumeSint64Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Int64Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, wire.DecodeZigZag(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, wire.DecodeZigZag(v))
	return n, nil
}

var coderSint64Slice = pointerCoderFuncs{
	size:      sizeSint64Slice,
	marshal:   appendSint64Slice,
	unmarshal: consumeSint64Slice,
}

// sizeSint64PackedSlice returns the size of wire encoding a []int64 pointer as a packed repeated Sint64.
func sizeSint64PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int64Slice()
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeZigZag(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendSint64PackedSlice encodes a []int64 pointer as a packed repeated Sint64.
func appendSint64PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int64Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeZigZag(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, wire.EncodeZigZag(v))
	}
	return b, nil
}

var coderSint64PackedSlice = pointerCoderFuncs{
	size:      sizeSint64PackedSlice,
	marshal:   appendSint64PackedSlice,
	unmarshal: consumeSint64Slice,
}

// sizeSint64Iface returns the size of wire encoding a int64 value as a Sint64.
func sizeSint64Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.(int64)
	return tagsize + wire.SizeVarint(wire.EncodeZigZag(v))
}

// appendSint64Iface encodes a int64 value as a Sint64.
func appendSint64Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(int64)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, wire.EncodeZigZag(v))
	return b, nil
}

// consumeSint64Iface decodes a int64 value as a Sint64.
func consumeSint64Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return wire.DecodeZigZag(v), n, nil
}

var coderSint64Iface = ifaceCoderFuncs{
	size:      sizeSint64Iface,
	marshal:   appendSint64Iface,
	unmarshal: consumeSint64Iface,
}

// sizeSint64SliceIface returns the size of wire encoding a []int64 value as a repeated Sint64.
func sizeSint64SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int64)
	for _, v := range s {
		size += tagsize + wire.SizeVarint(wire.EncodeZigZag(v))
	}
	return size
}

// appendSint64SliceIface encodes a []int64 value as a repeated Sint64.
func appendSint64SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int64)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, wire.EncodeZigZag(v))
	}
	return b, nil
}

// consumeSint64SliceIface wire decodes a []int64 value as a repeated Sint64.
func consumeSint64SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]int64)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, wire.DecodeZigZag(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, wire.DecodeZigZag(v))
	return ival, n, nil
}

var coderSint64SliceIface = ifaceCoderFuncs{
	size:      sizeSint64SliceIface,
	marshal:   appendSint64SliceIface,
	unmarshal: consumeSint64SliceIface,
}

// sizeSint64PackedSliceIface returns the size of wire encoding a []int64 value as a packed repeated Sint64.
func sizeSint64PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int64)
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeZigZag(v))
	}
	return tagsize + wire.SizeBytes(n)
}

// appendSint64PackedSliceIface encodes a []int64 value as a packed repeated Sint64.
func appendSint64PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int64)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(wire.EncodeZigZag(v))
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, wire.EncodeZigZag(v))
	}
	return b, nil
}

var coderSint64PackedSliceIface = ifaceCoderFuncs{
	size:      sizeSint64PackedSliceIface,
	marshal:   appendSint64PackedSliceIface,
	unmarshal: consumeSint64SliceIface,
}

// sizeUint64 returns the size of wire encoding a uint64 pointer as a Uint64.
func sizeUint64(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Uint64()
	return tagsize + wire.SizeVarint(v)
}

// appendUint64 wire encodes a uint64 pointer as a Uint64.
func appendUint64(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Uint64()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, v)
	return b, nil
}

// consumeUint64 wire decodes a uint64 pointer as a Uint64.
func consumeUint64(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Uint64() = v
	return n, nil
}

var coderUint64 = pointerCoderFuncs{
	size:      sizeUint64,
	marshal:   appendUint64,
	unmarshal: consumeUint64,
}

// sizeUint64NoZero returns the size of wire encoding a uint64 pointer as a Uint64.
// The zero value is not encoded.
func sizeUint64NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Uint64()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeVarint(v)
}

// appendUint64NoZero wire encodes a uint64 pointer as a Uint64.
// The zero value is not encoded.
func appendUint64NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Uint64()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, v)
	return b, nil
}

var coderUint64NoZero = pointerCoderFuncs{
	size:      sizeUint64NoZero,
	marshal:   appendUint64NoZero,
	unmarshal: consumeUint64,
}

// sizeUint64Ptr returns the size of wire encoding a *uint64 pointer as a Uint64.
// It panics if the pointer is nil.
func sizeUint64Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := **p.Uint64Ptr()
	return tagsize + wire.SizeVarint(v)
}

// appendUint64Ptr wire encodes a *uint64 pointer as a Uint64.
// It panics if the pointer is nil.
func appendUint64Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Uint64Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, v)
	return b, nil
}

// consumeUint64Ptr wire decodes a *uint64 pointer as a Uint64.
func consumeUint64Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Uint64Ptr()
	if *vp == nil {
		*vp = new(uint64)
	}
	**vp = v
	return n, nil
}

var coderUint64Ptr = pointerCoderFuncs{
	size:      sizeUint64Ptr,
	marshal:   appendUint64Ptr,
	unmarshal: consumeUint64Ptr,
}

// sizeUint64Slice returns the size of wire encoding a []uint64 pointer as a repeated Uint64.
func sizeUint64Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Uint64Slice()
	for _, v := range s {
		size += tagsize + wire.SizeVarint(v)
	}
	return size
}

// appendUint64Slice encodes a []uint64 pointer as a repeated Uint64.
func appendUint64Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Uint64Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, v)
	}
	return b, nil
}

// consumeUint64Slice wire decodes a []uint64 pointer as a repeated Uint64.
func consumeUint64Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Uint64Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, v)
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.VarintType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, v)
	return n, nil
}

var coderUint64Slice = pointerCoderFuncs{
	size:      sizeUint64Slice,
	marshal:   appendUint64Slice,
	unmarshal: consumeUint64Slice,
}

// sizeUint64PackedSlice returns the size of wire encoding a []uint64 pointer as a packed repeated Uint64.
func sizeUint64PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Uint64Slice()
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(v)
	}
	return tagsize + wire.SizeBytes(n)
}

// appendUint64PackedSlice encodes a []uint64 pointer as a packed repeated Uint64.
func appendUint64PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Uint64Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(v)
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, v)
	}
	return b, nil
}

var coderUint64PackedSlice = pointerCoderFuncs{
	size:      sizeUint64PackedSlice,
	marshal:   appendUint64PackedSlice,
	unmarshal: consumeUint64Slice,
}

// sizeUint64Iface returns the size of wire encoding a uint64 value as a Uint64.
func sizeUint64Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.(uint64)
	return tagsize + wire.SizeVarint(v)
}

// appendUint64Iface encodes a uint64 value as a Uint64.
func appendUint64Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(uint64)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendVarint(b, v)
	return b, nil
}

// consumeUint64Iface decodes a uint64 value as a Uint64.
func consumeUint64Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return v, n, nil
}

var coderUint64Iface = ifaceCoderFuncs{
	size:      sizeUint64Iface,
	marshal:   appendUint64Iface,
	unmarshal: consumeUint64Iface,
}

// sizeUint64SliceIface returns the size of wire encoding a []uint64 value as a repeated Uint64.
func sizeUint64SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]uint64)
	for _, v := range s {
		size += tagsize + wire.SizeVarint(v)
	}
	return size
}

// appendUint64SliceIface encodes a []uint64 value as a repeated Uint64.
func appendUint64SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]uint64)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendVarint(b, v)
	}
	return b, nil
}

// consumeUint64SliceIface wire decodes a []uint64 value as a repeated Uint64.
func consumeUint64SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]uint64)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeVarint(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, v)
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.VarintType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeVarint(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, v)
	return ival, n, nil
}

var coderUint64SliceIface = ifaceCoderFuncs{
	size:      sizeUint64SliceIface,
	marshal:   appendUint64SliceIface,
	unmarshal: consumeUint64SliceIface,
}

// sizeUint64PackedSliceIface returns the size of wire encoding a []uint64 value as a packed repeated Uint64.
func sizeUint64PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]uint64)
	if len(s) == 0 {
		return 0
	}
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(v)
	}
	return tagsize + wire.SizeBytes(n)
}

// appendUint64PackedSliceIface encodes a []uint64 value as a packed repeated Uint64.
func appendUint64PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]uint64)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := 0
	for _, v := range s {
		n += wire.SizeVarint(v)
	}
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendVarint(b, v)
	}
	return b, nil
}

var coderUint64PackedSliceIface = ifaceCoderFuncs{
	size:      sizeUint64PackedSliceIface,
	marshal:   appendUint64PackedSliceIface,
	unmarshal: consumeUint64SliceIface,
}

// sizeSfixed32 returns the size of wire encoding a int32 pointer as a Sfixed32.
func sizeSfixed32(p pointer, tagsize int, _ marshalOptions) (size int) {

	return tagsize + wire.SizeFixed32()
}

// appendSfixed32 wire encodes a int32 pointer as a Sfixed32.
func appendSfixed32(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int32()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, uint32(v))
	return b, nil
}

// consumeSfixed32 wire decodes a int32 pointer as a Sfixed32.
func consumeSfixed32(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Int32() = int32(v)
	return n, nil
}

var coderSfixed32 = pointerCoderFuncs{
	size:      sizeSfixed32,
	marshal:   appendSfixed32,
	unmarshal: consumeSfixed32,
}

// sizeSfixed32NoZero returns the size of wire encoding a int32 pointer as a Sfixed32.
// The zero value is not encoded.
func sizeSfixed32NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int32()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeFixed32()
}

// appendSfixed32NoZero wire encodes a int32 pointer as a Sfixed32.
// The zero value is not encoded.
func appendSfixed32NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int32()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, uint32(v))
	return b, nil
}

var coderSfixed32NoZero = pointerCoderFuncs{
	size:      sizeSfixed32NoZero,
	marshal:   appendSfixed32NoZero,
	unmarshal: consumeSfixed32,
}

// sizeSfixed32Ptr returns the size of wire encoding a *int32 pointer as a Sfixed32.
// It panics if the pointer is nil.
func sizeSfixed32Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	return tagsize + wire.SizeFixed32()
}

// appendSfixed32Ptr wire encodes a *int32 pointer as a Sfixed32.
// It panics if the pointer is nil.
func appendSfixed32Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Int32Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, uint32(v))
	return b, nil
}

// consumeSfixed32Ptr wire decodes a *int32 pointer as a Sfixed32.
func consumeSfixed32Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Int32Ptr()
	if *vp == nil {
		*vp = new(int32)
	}
	**vp = int32(v)
	return n, nil
}

var coderSfixed32Ptr = pointerCoderFuncs{
	size:      sizeSfixed32Ptr,
	marshal:   appendSfixed32Ptr,
	unmarshal: consumeSfixed32Ptr,
}

// sizeSfixed32Slice returns the size of wire encoding a []int32 pointer as a repeated Sfixed32.
func sizeSfixed32Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int32Slice()
	size = len(s) * (tagsize + wire.SizeFixed32())
	return size
}

// appendSfixed32Slice encodes a []int32 pointer as a repeated Sfixed32.
func appendSfixed32Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int32Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed32(b, uint32(v))
	}
	return b, nil
}

// consumeSfixed32Slice wire decodes a []int32 pointer as a repeated Sfixed32.
func consumeSfixed32Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Int32Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed32(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, int32(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, int32(v))
	return n, nil
}

var coderSfixed32Slice = pointerCoderFuncs{
	size:      sizeSfixed32Slice,
	marshal:   appendSfixed32Slice,
	unmarshal: consumeSfixed32Slice,
}

// sizeSfixed32PackedSlice returns the size of wire encoding a []int32 pointer as a packed repeated Sfixed32.
func sizeSfixed32PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int32Slice()
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed32()
	return tagsize + wire.SizeBytes(n)
}

// appendSfixed32PackedSlice encodes a []int32 pointer as a packed repeated Sfixed32.
func appendSfixed32PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int32Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed32()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed32(b, uint32(v))
	}
	return b, nil
}

var coderSfixed32PackedSlice = pointerCoderFuncs{
	size:      sizeSfixed32PackedSlice,
	marshal:   appendSfixed32PackedSlice,
	unmarshal: consumeSfixed32Slice,
}

// sizeSfixed32Iface returns the size of wire encoding a int32 value as a Sfixed32.
func sizeSfixed32Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	return tagsize + wire.SizeFixed32()
}

// appendSfixed32Iface encodes a int32 value as a Sfixed32.
func appendSfixed32Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(int32)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, uint32(v))
	return b, nil
}

// consumeSfixed32Iface decodes a int32 value as a Sfixed32.
func consumeSfixed32Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.Fixed32Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return int32(v), n, nil
}

var coderSfixed32Iface = ifaceCoderFuncs{
	size:      sizeSfixed32Iface,
	marshal:   appendSfixed32Iface,
	unmarshal: consumeSfixed32Iface,
}

// sizeSfixed32SliceIface returns the size of wire encoding a []int32 value as a repeated Sfixed32.
func sizeSfixed32SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int32)
	size = len(s) * (tagsize + wire.SizeFixed32())
	return size
}

// appendSfixed32SliceIface encodes a []int32 value as a repeated Sfixed32.
func appendSfixed32SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int32)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed32(b, uint32(v))
	}
	return b, nil
}

// consumeSfixed32SliceIface wire decodes a []int32 value as a repeated Sfixed32.
func consumeSfixed32SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]int32)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed32(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, int32(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.Fixed32Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, int32(v))
	return ival, n, nil
}

var coderSfixed32SliceIface = ifaceCoderFuncs{
	size:      sizeSfixed32SliceIface,
	marshal:   appendSfixed32SliceIface,
	unmarshal: consumeSfixed32SliceIface,
}

// sizeSfixed32PackedSliceIface returns the size of wire encoding a []int32 value as a packed repeated Sfixed32.
func sizeSfixed32PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int32)
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed32()
	return tagsize + wire.SizeBytes(n)
}

// appendSfixed32PackedSliceIface encodes a []int32 value as a packed repeated Sfixed32.
func appendSfixed32PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int32)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed32()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed32(b, uint32(v))
	}
	return b, nil
}

var coderSfixed32PackedSliceIface = ifaceCoderFuncs{
	size:      sizeSfixed32PackedSliceIface,
	marshal:   appendSfixed32PackedSliceIface,
	unmarshal: consumeSfixed32SliceIface,
}

// sizeFixed32 returns the size of wire encoding a uint32 pointer as a Fixed32.
func sizeFixed32(p pointer, tagsize int, _ marshalOptions) (size int) {

	return tagsize + wire.SizeFixed32()
}

// appendFixed32 wire encodes a uint32 pointer as a Fixed32.
func appendFixed32(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Uint32()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, v)
	return b, nil
}

// consumeFixed32 wire decodes a uint32 pointer as a Fixed32.
func consumeFixed32(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Uint32() = v
	return n, nil
}

var coderFixed32 = pointerCoderFuncs{
	size:      sizeFixed32,
	marshal:   appendFixed32,
	unmarshal: consumeFixed32,
}

// sizeFixed32NoZero returns the size of wire encoding a uint32 pointer as a Fixed32.
// The zero value is not encoded.
func sizeFixed32NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Uint32()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeFixed32()
}

// appendFixed32NoZero wire encodes a uint32 pointer as a Fixed32.
// The zero value is not encoded.
func appendFixed32NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Uint32()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, v)
	return b, nil
}

var coderFixed32NoZero = pointerCoderFuncs{
	size:      sizeFixed32NoZero,
	marshal:   appendFixed32NoZero,
	unmarshal: consumeFixed32,
}

// sizeFixed32Ptr returns the size of wire encoding a *uint32 pointer as a Fixed32.
// It panics if the pointer is nil.
func sizeFixed32Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	return tagsize + wire.SizeFixed32()
}

// appendFixed32Ptr wire encodes a *uint32 pointer as a Fixed32.
// It panics if the pointer is nil.
func appendFixed32Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Uint32Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, v)
	return b, nil
}

// consumeFixed32Ptr wire decodes a *uint32 pointer as a Fixed32.
func consumeFixed32Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Uint32Ptr()
	if *vp == nil {
		*vp = new(uint32)
	}
	**vp = v
	return n, nil
}

var coderFixed32Ptr = pointerCoderFuncs{
	size:      sizeFixed32Ptr,
	marshal:   appendFixed32Ptr,
	unmarshal: consumeFixed32Ptr,
}

// sizeFixed32Slice returns the size of wire encoding a []uint32 pointer as a repeated Fixed32.
func sizeFixed32Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Uint32Slice()
	size = len(s) * (tagsize + wire.SizeFixed32())
	return size
}

// appendFixed32Slice encodes a []uint32 pointer as a repeated Fixed32.
func appendFixed32Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Uint32Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed32(b, v)
	}
	return b, nil
}

// consumeFixed32Slice wire decodes a []uint32 pointer as a repeated Fixed32.
func consumeFixed32Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Uint32Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed32(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, v)
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, v)
	return n, nil
}

var coderFixed32Slice = pointerCoderFuncs{
	size:      sizeFixed32Slice,
	marshal:   appendFixed32Slice,
	unmarshal: consumeFixed32Slice,
}

// sizeFixed32PackedSlice returns the size of wire encoding a []uint32 pointer as a packed repeated Fixed32.
func sizeFixed32PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Uint32Slice()
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed32()
	return tagsize + wire.SizeBytes(n)
}

// appendFixed32PackedSlice encodes a []uint32 pointer as a packed repeated Fixed32.
func appendFixed32PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Uint32Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed32()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed32(b, v)
	}
	return b, nil
}

var coderFixed32PackedSlice = pointerCoderFuncs{
	size:      sizeFixed32PackedSlice,
	marshal:   appendFixed32PackedSlice,
	unmarshal: consumeFixed32Slice,
}

// sizeFixed32Iface returns the size of wire encoding a uint32 value as a Fixed32.
func sizeFixed32Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	return tagsize + wire.SizeFixed32()
}

// appendFixed32Iface encodes a uint32 value as a Fixed32.
func appendFixed32Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(uint32)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, v)
	return b, nil
}

// consumeFixed32Iface decodes a uint32 value as a Fixed32.
func consumeFixed32Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.Fixed32Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return v, n, nil
}

var coderFixed32Iface = ifaceCoderFuncs{
	size:      sizeFixed32Iface,
	marshal:   appendFixed32Iface,
	unmarshal: consumeFixed32Iface,
}

// sizeFixed32SliceIface returns the size of wire encoding a []uint32 value as a repeated Fixed32.
func sizeFixed32SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]uint32)
	size = len(s) * (tagsize + wire.SizeFixed32())
	return size
}

// appendFixed32SliceIface encodes a []uint32 value as a repeated Fixed32.
func appendFixed32SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]uint32)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed32(b, v)
	}
	return b, nil
}

// consumeFixed32SliceIface wire decodes a []uint32 value as a repeated Fixed32.
func consumeFixed32SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]uint32)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed32(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, v)
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.Fixed32Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, v)
	return ival, n, nil
}

var coderFixed32SliceIface = ifaceCoderFuncs{
	size:      sizeFixed32SliceIface,
	marshal:   appendFixed32SliceIface,
	unmarshal: consumeFixed32SliceIface,
}

// sizeFixed32PackedSliceIface returns the size of wire encoding a []uint32 value as a packed repeated Fixed32.
func sizeFixed32PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]uint32)
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed32()
	return tagsize + wire.SizeBytes(n)
}

// appendFixed32PackedSliceIface encodes a []uint32 value as a packed repeated Fixed32.
func appendFixed32PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]uint32)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed32()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed32(b, v)
	}
	return b, nil
}

var coderFixed32PackedSliceIface = ifaceCoderFuncs{
	size:      sizeFixed32PackedSliceIface,
	marshal:   appendFixed32PackedSliceIface,
	unmarshal: consumeFixed32SliceIface,
}

// sizeFloat returns the size of wire encoding a float32 pointer as a Float.
func sizeFloat(p pointer, tagsize int, _ marshalOptions) (size int) {

	return tagsize + wire.SizeFixed32()
}

// appendFloat wire encodes a float32 pointer as a Float.
func appendFloat(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Float32()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, math.Float32bits(v))
	return b, nil
}

// consumeFloat wire decodes a float32 pointer as a Float.
func consumeFloat(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Float32() = math.Float32frombits(v)
	return n, nil
}

var coderFloat = pointerCoderFuncs{
	size:      sizeFloat,
	marshal:   appendFloat,
	unmarshal: consumeFloat,
}

// sizeFloatNoZero returns the size of wire encoding a float32 pointer as a Float.
// The zero value is not encoded.
func sizeFloatNoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Float32()
	if v == 0 && !math.Signbit(float64(v)) {
		return 0
	}
	return tagsize + wire.SizeFixed32()
}

// appendFloatNoZero wire encodes a float32 pointer as a Float.
// The zero value is not encoded.
func appendFloatNoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Float32()
	if v == 0 && !math.Signbit(float64(v)) {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, math.Float32bits(v))
	return b, nil
}

var coderFloatNoZero = pointerCoderFuncs{
	size:      sizeFloatNoZero,
	marshal:   appendFloatNoZero,
	unmarshal: consumeFloat,
}

// sizeFloatPtr returns the size of wire encoding a *float32 pointer as a Float.
// It panics if the pointer is nil.
func sizeFloatPtr(p pointer, tagsize int, _ marshalOptions) (size int) {
	return tagsize + wire.SizeFixed32()
}

// appendFloatPtr wire encodes a *float32 pointer as a Float.
// It panics if the pointer is nil.
func appendFloatPtr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Float32Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, math.Float32bits(v))
	return b, nil
}

// consumeFloatPtr wire decodes a *float32 pointer as a Float.
func consumeFloatPtr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Float32Ptr()
	if *vp == nil {
		*vp = new(float32)
	}
	**vp = math.Float32frombits(v)
	return n, nil
}

var coderFloatPtr = pointerCoderFuncs{
	size:      sizeFloatPtr,
	marshal:   appendFloatPtr,
	unmarshal: consumeFloatPtr,
}

// sizeFloatSlice returns the size of wire encoding a []float32 pointer as a repeated Float.
func sizeFloatSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Float32Slice()
	size = len(s) * (tagsize + wire.SizeFixed32())
	return size
}

// appendFloatSlice encodes a []float32 pointer as a repeated Float.
func appendFloatSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Float32Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed32(b, math.Float32bits(v))
	}
	return b, nil
}

// consumeFloatSlice wire decodes a []float32 pointer as a repeated Float.
func consumeFloatSlice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Float32Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed32(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, math.Float32frombits(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.Fixed32Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, math.Float32frombits(v))
	return n, nil
}

var coderFloatSlice = pointerCoderFuncs{
	size:      sizeFloatSlice,
	marshal:   appendFloatSlice,
	unmarshal: consumeFloatSlice,
}

// sizeFloatPackedSlice returns the size of wire encoding a []float32 pointer as a packed repeated Float.
func sizeFloatPackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Float32Slice()
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed32()
	return tagsize + wire.SizeBytes(n)
}

// appendFloatPackedSlice encodes a []float32 pointer as a packed repeated Float.
func appendFloatPackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Float32Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed32()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed32(b, math.Float32bits(v))
	}
	return b, nil
}

var coderFloatPackedSlice = pointerCoderFuncs{
	size:      sizeFloatPackedSlice,
	marshal:   appendFloatPackedSlice,
	unmarshal: consumeFloatSlice,
}

// sizeFloatIface returns the size of wire encoding a float32 value as a Float.
func sizeFloatIface(ival interface{}, tagsize int, _ marshalOptions) int {
	return tagsize + wire.SizeFixed32()
}

// appendFloatIface encodes a float32 value as a Float.
func appendFloatIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(float32)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed32(b, math.Float32bits(v))
	return b, nil
}

// consumeFloatIface decodes a float32 value as a Float.
func consumeFloatIface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.Fixed32Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return math.Float32frombits(v), n, nil
}

var coderFloatIface = ifaceCoderFuncs{
	size:      sizeFloatIface,
	marshal:   appendFloatIface,
	unmarshal: consumeFloatIface,
}

// sizeFloatSliceIface returns the size of wire encoding a []float32 value as a repeated Float.
func sizeFloatSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]float32)
	size = len(s) * (tagsize + wire.SizeFixed32())
	return size
}

// appendFloatSliceIface encodes a []float32 value as a repeated Float.
func appendFloatSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]float32)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed32(b, math.Float32bits(v))
	}
	return b, nil
}

// consumeFloatSliceIface wire decodes a []float32 value as a repeated Float.
func consumeFloatSliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]float32)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed32(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, math.Float32frombits(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.Fixed32Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed32(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, math.Float32frombits(v))
	return ival, n, nil
}

var coderFloatSliceIface = ifaceCoderFuncs{
	size:      sizeFloatSliceIface,
	marshal:   appendFloatSliceIface,
	unmarshal: consumeFloatSliceIface,
}

// sizeFloatPackedSliceIface returns the size of wire encoding a []float32 value as a packed repeated Float.
func sizeFloatPackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]float32)
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed32()
	return tagsize + wire.SizeBytes(n)
}

// appendFloatPackedSliceIface encodes a []float32 value as a packed repeated Float.
func appendFloatPackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]float32)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed32()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed32(b, math.Float32bits(v))
	}
	return b, nil
}

var coderFloatPackedSliceIface = ifaceCoderFuncs{
	size:      sizeFloatPackedSliceIface,
	marshal:   appendFloatPackedSliceIface,
	unmarshal: consumeFloatSliceIface,
}

// sizeSfixed64 returns the size of wire encoding a int64 pointer as a Sfixed64.
func sizeSfixed64(p pointer, tagsize int, _ marshalOptions) (size int) {

	return tagsize + wire.SizeFixed64()
}

// appendSfixed64 wire encodes a int64 pointer as a Sfixed64.
func appendSfixed64(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int64()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, uint64(v))
	return b, nil
}

// consumeSfixed64 wire decodes a int64 pointer as a Sfixed64.
func consumeSfixed64(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Int64() = int64(v)
	return n, nil
}

var coderSfixed64 = pointerCoderFuncs{
	size:      sizeSfixed64,
	marshal:   appendSfixed64,
	unmarshal: consumeSfixed64,
}

// sizeSfixed64NoZero returns the size of wire encoding a int64 pointer as a Sfixed64.
// The zero value is not encoded.
func sizeSfixed64NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Int64()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeFixed64()
}

// appendSfixed64NoZero wire encodes a int64 pointer as a Sfixed64.
// The zero value is not encoded.
func appendSfixed64NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Int64()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, uint64(v))
	return b, nil
}

var coderSfixed64NoZero = pointerCoderFuncs{
	size:      sizeSfixed64NoZero,
	marshal:   appendSfixed64NoZero,
	unmarshal: consumeSfixed64,
}

// sizeSfixed64Ptr returns the size of wire encoding a *int64 pointer as a Sfixed64.
// It panics if the pointer is nil.
func sizeSfixed64Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	return tagsize + wire.SizeFixed64()
}

// appendSfixed64Ptr wire encodes a *int64 pointer as a Sfixed64.
// It panics if the pointer is nil.
func appendSfixed64Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Int64Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, uint64(v))
	return b, nil
}

// consumeSfixed64Ptr wire decodes a *int64 pointer as a Sfixed64.
func consumeSfixed64Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Int64Ptr()
	if *vp == nil {
		*vp = new(int64)
	}
	**vp = int64(v)
	return n, nil
}

var coderSfixed64Ptr = pointerCoderFuncs{
	size:      sizeSfixed64Ptr,
	marshal:   appendSfixed64Ptr,
	unmarshal: consumeSfixed64Ptr,
}

// sizeSfixed64Slice returns the size of wire encoding a []int64 pointer as a repeated Sfixed64.
func sizeSfixed64Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int64Slice()
	size = len(s) * (tagsize + wire.SizeFixed64())
	return size
}

// appendSfixed64Slice encodes a []int64 pointer as a repeated Sfixed64.
func appendSfixed64Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int64Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed64(b, uint64(v))
	}
	return b, nil
}

// consumeSfixed64Slice wire decodes a []int64 pointer as a repeated Sfixed64.
func consumeSfixed64Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Int64Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed64(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, int64(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, int64(v))
	return n, nil
}

var coderSfixed64Slice = pointerCoderFuncs{
	size:      sizeSfixed64Slice,
	marshal:   appendSfixed64Slice,
	unmarshal: consumeSfixed64Slice,
}

// sizeSfixed64PackedSlice returns the size of wire encoding a []int64 pointer as a packed repeated Sfixed64.
func sizeSfixed64PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Int64Slice()
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed64()
	return tagsize + wire.SizeBytes(n)
}

// appendSfixed64PackedSlice encodes a []int64 pointer as a packed repeated Sfixed64.
func appendSfixed64PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Int64Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed64()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed64(b, uint64(v))
	}
	return b, nil
}

var coderSfixed64PackedSlice = pointerCoderFuncs{
	size:      sizeSfixed64PackedSlice,
	marshal:   appendSfixed64PackedSlice,
	unmarshal: consumeSfixed64Slice,
}

// sizeSfixed64Iface returns the size of wire encoding a int64 value as a Sfixed64.
func sizeSfixed64Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	return tagsize + wire.SizeFixed64()
}

// appendSfixed64Iface encodes a int64 value as a Sfixed64.
func appendSfixed64Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(int64)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, uint64(v))
	return b, nil
}

// consumeSfixed64Iface decodes a int64 value as a Sfixed64.
func consumeSfixed64Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.Fixed64Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return int64(v), n, nil
}

var coderSfixed64Iface = ifaceCoderFuncs{
	size:      sizeSfixed64Iface,
	marshal:   appendSfixed64Iface,
	unmarshal: consumeSfixed64Iface,
}

// sizeSfixed64SliceIface returns the size of wire encoding a []int64 value as a repeated Sfixed64.
func sizeSfixed64SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int64)
	size = len(s) * (tagsize + wire.SizeFixed64())
	return size
}

// appendSfixed64SliceIface encodes a []int64 value as a repeated Sfixed64.
func appendSfixed64SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int64)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed64(b, uint64(v))
	}
	return b, nil
}

// consumeSfixed64SliceIface wire decodes a []int64 value as a repeated Sfixed64.
func consumeSfixed64SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]int64)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed64(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, int64(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.Fixed64Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, int64(v))
	return ival, n, nil
}

var coderSfixed64SliceIface = ifaceCoderFuncs{
	size:      sizeSfixed64SliceIface,
	marshal:   appendSfixed64SliceIface,
	unmarshal: consumeSfixed64SliceIface,
}

// sizeSfixed64PackedSliceIface returns the size of wire encoding a []int64 value as a packed repeated Sfixed64.
func sizeSfixed64PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]int64)
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed64()
	return tagsize + wire.SizeBytes(n)
}

// appendSfixed64PackedSliceIface encodes a []int64 value as a packed repeated Sfixed64.
func appendSfixed64PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]int64)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed64()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed64(b, uint64(v))
	}
	return b, nil
}

var coderSfixed64PackedSliceIface = ifaceCoderFuncs{
	size:      sizeSfixed64PackedSliceIface,
	marshal:   appendSfixed64PackedSliceIface,
	unmarshal: consumeSfixed64SliceIface,
}

// sizeFixed64 returns the size of wire encoding a uint64 pointer as a Fixed64.
func sizeFixed64(p pointer, tagsize int, _ marshalOptions) (size int) {

	return tagsize + wire.SizeFixed64()
}

// appendFixed64 wire encodes a uint64 pointer as a Fixed64.
func appendFixed64(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Uint64()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, v)
	return b, nil
}

// consumeFixed64 wire decodes a uint64 pointer as a Fixed64.
func consumeFixed64(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Uint64() = v
	return n, nil
}

var coderFixed64 = pointerCoderFuncs{
	size:      sizeFixed64,
	marshal:   appendFixed64,
	unmarshal: consumeFixed64,
}

// sizeFixed64NoZero returns the size of wire encoding a uint64 pointer as a Fixed64.
// The zero value is not encoded.
func sizeFixed64NoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Uint64()
	if v == 0 {
		return 0
	}
	return tagsize + wire.SizeFixed64()
}

// appendFixed64NoZero wire encodes a uint64 pointer as a Fixed64.
// The zero value is not encoded.
func appendFixed64NoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Uint64()
	if v == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, v)
	return b, nil
}

var coderFixed64NoZero = pointerCoderFuncs{
	size:      sizeFixed64NoZero,
	marshal:   appendFixed64NoZero,
	unmarshal: consumeFixed64,
}

// sizeFixed64Ptr returns the size of wire encoding a *uint64 pointer as a Fixed64.
// It panics if the pointer is nil.
func sizeFixed64Ptr(p pointer, tagsize int, _ marshalOptions) (size int) {
	return tagsize + wire.SizeFixed64()
}

// appendFixed64Ptr wire encodes a *uint64 pointer as a Fixed64.
// It panics if the pointer is nil.
func appendFixed64Ptr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Uint64Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, v)
	return b, nil
}

// consumeFixed64Ptr wire decodes a *uint64 pointer as a Fixed64.
func consumeFixed64Ptr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Uint64Ptr()
	if *vp == nil {
		*vp = new(uint64)
	}
	**vp = v
	return n, nil
}

var coderFixed64Ptr = pointerCoderFuncs{
	size:      sizeFixed64Ptr,
	marshal:   appendFixed64Ptr,
	unmarshal: consumeFixed64Ptr,
}

// sizeFixed64Slice returns the size of wire encoding a []uint64 pointer as a repeated Fixed64.
func sizeFixed64Slice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Uint64Slice()
	size = len(s) * (tagsize + wire.SizeFixed64())
	return size
}

// appendFixed64Slice encodes a []uint64 pointer as a repeated Fixed64.
func appendFixed64Slice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Uint64Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed64(b, v)
	}
	return b, nil
}

// consumeFixed64Slice wire decodes a []uint64 pointer as a repeated Fixed64.
func consumeFixed64Slice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Uint64Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed64(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, v)
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, v)
	return n, nil
}

var coderFixed64Slice = pointerCoderFuncs{
	size:      sizeFixed64Slice,
	marshal:   appendFixed64Slice,
	unmarshal: consumeFixed64Slice,
}

// sizeFixed64PackedSlice returns the size of wire encoding a []uint64 pointer as a packed repeated Fixed64.
func sizeFixed64PackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Uint64Slice()
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed64()
	return tagsize + wire.SizeBytes(n)
}

// appendFixed64PackedSlice encodes a []uint64 pointer as a packed repeated Fixed64.
func appendFixed64PackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Uint64Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed64()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed64(b, v)
	}
	return b, nil
}

var coderFixed64PackedSlice = pointerCoderFuncs{
	size:      sizeFixed64PackedSlice,
	marshal:   appendFixed64PackedSlice,
	unmarshal: consumeFixed64Slice,
}

// sizeFixed64Iface returns the size of wire encoding a uint64 value as a Fixed64.
func sizeFixed64Iface(ival interface{}, tagsize int, _ marshalOptions) int {
	return tagsize + wire.SizeFixed64()
}

// appendFixed64Iface encodes a uint64 value as a Fixed64.
func appendFixed64Iface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(uint64)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, v)
	return b, nil
}

// consumeFixed64Iface decodes a uint64 value as a Fixed64.
func consumeFixed64Iface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.Fixed64Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return v, n, nil
}

var coderFixed64Iface = ifaceCoderFuncs{
	size:      sizeFixed64Iface,
	marshal:   appendFixed64Iface,
	unmarshal: consumeFixed64Iface,
}

// sizeFixed64SliceIface returns the size of wire encoding a []uint64 value as a repeated Fixed64.
func sizeFixed64SliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]uint64)
	size = len(s) * (tagsize + wire.SizeFixed64())
	return size
}

// appendFixed64SliceIface encodes a []uint64 value as a repeated Fixed64.
func appendFixed64SliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]uint64)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed64(b, v)
	}
	return b, nil
}

// consumeFixed64SliceIface wire decodes a []uint64 value as a repeated Fixed64.
func consumeFixed64SliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]uint64)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed64(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, v)
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.Fixed64Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, v)
	return ival, n, nil
}

var coderFixed64SliceIface = ifaceCoderFuncs{
	size:      sizeFixed64SliceIface,
	marshal:   appendFixed64SliceIface,
	unmarshal: consumeFixed64SliceIface,
}

// sizeFixed64PackedSliceIface returns the size of wire encoding a []uint64 value as a packed repeated Fixed64.
func sizeFixed64PackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]uint64)
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed64()
	return tagsize + wire.SizeBytes(n)
}

// appendFixed64PackedSliceIface encodes a []uint64 value as a packed repeated Fixed64.
func appendFixed64PackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]uint64)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed64()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed64(b, v)
	}
	return b, nil
}

var coderFixed64PackedSliceIface = ifaceCoderFuncs{
	size:      sizeFixed64PackedSliceIface,
	marshal:   appendFixed64PackedSliceIface,
	unmarshal: consumeFixed64SliceIface,
}

// sizeDouble returns the size of wire encoding a float64 pointer as a Double.
func sizeDouble(p pointer, tagsize int, _ marshalOptions) (size int) {

	return tagsize + wire.SizeFixed64()
}

// appendDouble wire encodes a float64 pointer as a Double.
func appendDouble(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Float64()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, math.Float64bits(v))
	return b, nil
}

// consumeDouble wire decodes a float64 pointer as a Double.
func consumeDouble(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Float64() = math.Float64frombits(v)
	return n, nil
}

var coderDouble = pointerCoderFuncs{
	size:      sizeDouble,
	marshal:   appendDouble,
	unmarshal: consumeDouble,
}

// sizeDoubleNoZero returns the size of wire encoding a float64 pointer as a Double.
// The zero value is not encoded.
func sizeDoubleNoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Float64()
	if v == 0 && !math.Signbit(float64(v)) {
		return 0
	}
	return tagsize + wire.SizeFixed64()
}

// appendDoubleNoZero wire encodes a float64 pointer as a Double.
// The zero value is not encoded.
func appendDoubleNoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Float64()
	if v == 0 && !math.Signbit(float64(v)) {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, math.Float64bits(v))
	return b, nil
}

var coderDoubleNoZero = pointerCoderFuncs{
	size:      sizeDoubleNoZero,
	marshal:   appendDoubleNoZero,
	unmarshal: consumeDouble,
}

// sizeDoublePtr returns the size of wire encoding a *float64 pointer as a Double.
// It panics if the pointer is nil.
func sizeDoublePtr(p pointer, tagsize int, _ marshalOptions) (size int) {
	return tagsize + wire.SizeFixed64()
}

// appendDoublePtr wire encodes a *float64 pointer as a Double.
// It panics if the pointer is nil.
func appendDoublePtr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.Float64Ptr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, math.Float64bits(v))
	return b, nil
}

// consumeDoublePtr wire decodes a *float64 pointer as a Double.
func consumeDoublePtr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.Float64Ptr()
	if *vp == nil {
		*vp = new(float64)
	}
	**vp = math.Float64frombits(v)
	return n, nil
}

var coderDoublePtr = pointerCoderFuncs{
	size:      sizeDoublePtr,
	marshal:   appendDoublePtr,
	unmarshal: consumeDoublePtr,
}

// sizeDoubleSlice returns the size of wire encoding a []float64 pointer as a repeated Double.
func sizeDoubleSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Float64Slice()
	size = len(s) * (tagsize + wire.SizeFixed64())
	return size
}

// appendDoubleSlice encodes a []float64 pointer as a repeated Double.
func appendDoubleSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Float64Slice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed64(b, math.Float64bits(v))
	}
	return b, nil
}

// consumeDoubleSlice wire decodes a []float64 pointer as a repeated Double.
func consumeDoubleSlice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.Float64Slice()
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed64(b)
			if n < 0 {
				return 0, wire.ParseError(n)
			}
			s = append(s, math.Float64frombits(v))
			b = b[n:]
		}
		*sp = s
		return n, nil
	}
	if wtyp != wire.Fixed64Type {
		return 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, math.Float64frombits(v))
	return n, nil
}

var coderDoubleSlice = pointerCoderFuncs{
	size:      sizeDoubleSlice,
	marshal:   appendDoubleSlice,
	unmarshal: consumeDoubleSlice,
}

// sizeDoublePackedSlice returns the size of wire encoding a []float64 pointer as a packed repeated Double.
func sizeDoublePackedSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.Float64Slice()
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed64()
	return tagsize + wire.SizeBytes(n)
}

// appendDoublePackedSlice encodes a []float64 pointer as a packed repeated Double.
func appendDoublePackedSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.Float64Slice()
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed64()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed64(b, math.Float64bits(v))
	}
	return b, nil
}

var coderDoublePackedSlice = pointerCoderFuncs{
	size:      sizeDoublePackedSlice,
	marshal:   appendDoublePackedSlice,
	unmarshal: consumeDoubleSlice,
}

// sizeDoubleIface returns the size of wire encoding a float64 value as a Double.
func sizeDoubleIface(ival interface{}, tagsize int, _ marshalOptions) int {
	return tagsize + wire.SizeFixed64()
}

// appendDoubleIface encodes a float64 value as a Double.
func appendDoubleIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(float64)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendFixed64(b, math.Float64bits(v))
	return b, nil
}

// consumeDoubleIface decodes a float64 value as a Double.
func consumeDoubleIface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.Fixed64Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return math.Float64frombits(v), n, nil
}

var coderDoubleIface = ifaceCoderFuncs{
	size:      sizeDoubleIface,
	marshal:   appendDoubleIface,
	unmarshal: consumeDoubleIface,
}

// sizeDoubleSliceIface returns the size of wire encoding a []float64 value as a repeated Double.
func sizeDoubleSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]float64)
	size = len(s) * (tagsize + wire.SizeFixed64())
	return size
}

// appendDoubleSliceIface encodes a []float64 value as a repeated Double.
func appendDoubleSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]float64)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendFixed64(b, math.Float64bits(v))
	}
	return b, nil
}

// consumeDoubleSliceIface wire decodes a []float64 value as a repeated Double.
func consumeDoubleSliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]float64)
	if wtyp == wire.BytesType {
		s := *sp
		b, n = wire.ConsumeBytes(b)
		if n < 0 {
			return nil, 0, wire.ParseError(n)
		}
		for len(b) > 0 {
			v, n := wire.ConsumeFixed64(b)
			if n < 0 {
				return nil, 0, wire.ParseError(n)
			}
			s = append(s, math.Float64frombits(v))
			b = b[n:]
		}
		*sp = s
		return ival, n, nil
	}
	if wtyp != wire.Fixed64Type {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeFixed64(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, math.Float64frombits(v))
	return ival, n, nil
}

var coderDoubleSliceIface = ifaceCoderFuncs{
	size:      sizeDoubleSliceIface,
	marshal:   appendDoubleSliceIface,
	unmarshal: consumeDoubleSliceIface,
}

// sizeDoublePackedSliceIface returns the size of wire encoding a []float64 value as a packed repeated Double.
func sizeDoublePackedSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]float64)
	if len(s) == 0 {
		return 0
	}
	n := len(s) * wire.SizeFixed64()
	return tagsize + wire.SizeBytes(n)
}

// appendDoublePackedSliceIface encodes a []float64 value as a packed repeated Double.
func appendDoublePackedSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]float64)
	if len(s) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	n := len(s) * wire.SizeFixed64()
	b = wire.AppendVarint(b, uint64(n))
	for _, v := range s {
		b = wire.AppendFixed64(b, math.Float64bits(v))
	}
	return b, nil
}

var coderDoublePackedSliceIface = ifaceCoderFuncs{
	size:      sizeDoublePackedSliceIface,
	marshal:   appendDoublePackedSliceIface,
	unmarshal: consumeDoubleSliceIface,
}

// sizeString returns the size of wire encoding a string pointer as a String.
func sizeString(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.String()
	return tagsize + wire.SizeBytes(len(v))
}

// appendString wire encodes a string pointer as a String.
func appendString(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.String()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendString(b, v)
	return b, nil
}

// consumeString wire decodes a string pointer as a String.
func consumeString(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeString(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.String() = v
	return n, nil
}

var coderString = pointerCoderFuncs{
	size:      sizeString,
	marshal:   appendString,
	unmarshal: consumeString,
}

// appendStringValidateUTF8 wire encodes a string pointer as a String.
func appendStringValidateUTF8(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.String()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendString(b, v)
	if !utf8.ValidString(v) {
		return b, errInvalidUTF8{}
	}
	return b, nil
}

// consumeStringValidateUTF8 wire decodes a string pointer as a String.
func consumeStringValidateUTF8(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeString(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	if !utf8.ValidString(v) {
		return 0, errInvalidUTF8{}
	}
	*p.String() = v
	return n, nil
}

var coderStringValidateUTF8 = pointerCoderFuncs{
	size:      sizeString,
	marshal:   appendStringValidateUTF8,
	unmarshal: consumeStringValidateUTF8,
}

// sizeStringNoZero returns the size of wire encoding a string pointer as a String.
// The zero value is not encoded.
func sizeStringNoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.String()
	if len(v) == 0 {
		return 0
	}
	return tagsize + wire.SizeBytes(len(v))
}

// appendStringNoZero wire encodes a string pointer as a String.
// The zero value is not encoded.
func appendStringNoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.String()
	if len(v) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendString(b, v)
	return b, nil
}

var coderStringNoZero = pointerCoderFuncs{
	size:      sizeStringNoZero,
	marshal:   appendStringNoZero,
	unmarshal: consumeString,
}

// appendStringNoZeroValidateUTF8 wire encodes a string pointer as a String.
// The zero value is not encoded.
func appendStringNoZeroValidateUTF8(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.String()
	if len(v) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendString(b, v)
	if !utf8.ValidString(v) {
		return b, errInvalidUTF8{}
	}
	return b, nil
}

var coderStringNoZeroValidateUTF8 = pointerCoderFuncs{
	size:      sizeStringNoZero,
	marshal:   appendStringNoZeroValidateUTF8,
	unmarshal: consumeStringValidateUTF8,
}

// sizeStringPtr returns the size of wire encoding a *string pointer as a String.
// It panics if the pointer is nil.
func sizeStringPtr(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := **p.StringPtr()
	return tagsize + wire.SizeBytes(len(v))
}

// appendStringPtr wire encodes a *string pointer as a String.
// It panics if the pointer is nil.
func appendStringPtr(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := **p.StringPtr()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendString(b, v)
	return b, nil
}

// consumeStringPtr wire decodes a *string pointer as a String.
func consumeStringPtr(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeString(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	vp := p.StringPtr()
	if *vp == nil {
		*vp = new(string)
	}
	**vp = v
	return n, nil
}

var coderStringPtr = pointerCoderFuncs{
	size:      sizeStringPtr,
	marshal:   appendStringPtr,
	unmarshal: consumeStringPtr,
}

// sizeStringSlice returns the size of wire encoding a []string pointer as a repeated String.
func sizeStringSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.StringSlice()
	for _, v := range s {
		size += tagsize + wire.SizeBytes(len(v))
	}
	return size
}

// appendStringSlice encodes a []string pointer as a repeated String.
func appendStringSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.StringSlice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendString(b, v)
	}
	return b, nil
}

// consumeStringSlice wire decodes a []string pointer as a repeated String.
func consumeStringSlice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.StringSlice()
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeString(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, v)
	return n, nil
}

var coderStringSlice = pointerCoderFuncs{
	size:      sizeStringSlice,
	marshal:   appendStringSlice,
	unmarshal: consumeStringSlice,
}

// appendStringSliceValidateUTF8 encodes a []string pointer as a repeated String.
func appendStringSliceValidateUTF8(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.StringSlice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendString(b, v)
		if !utf8.ValidString(v) {
			return b, errInvalidUTF8{}
		}
	}
	return b, nil
}

// consumeStringSliceValidateUTF8 wire decodes a []string pointer as a repeated String.
func consumeStringSliceValidateUTF8(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.StringSlice()
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeString(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	if !utf8.ValidString(v) {
		return 0, errInvalidUTF8{}
	}
	*sp = append(*sp, v)
	return n, nil
}

var coderStringSliceValidateUTF8 = pointerCoderFuncs{
	size:      sizeStringSlice,
	marshal:   appendStringSliceValidateUTF8,
	unmarshal: consumeStringSliceValidateUTF8,
}

// sizeStringIface returns the size of wire encoding a string value as a String.
func sizeStringIface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.(string)
	return tagsize + wire.SizeBytes(len(v))
}

// appendStringIface encodes a string value as a String.
func appendStringIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(string)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendString(b, v)
	return b, nil
}

// consumeStringIface decodes a string value as a String.
func consumeStringIface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.BytesType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeString(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return v, n, nil
}

var coderStringIface = ifaceCoderFuncs{
	size:      sizeStringIface,
	marshal:   appendStringIface,
	unmarshal: consumeStringIface,
}

// appendStringIfaceValidateUTF8 encodes a string value as a String.
func appendStringIfaceValidateUTF8(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.(string)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendString(b, v)
	if !utf8.ValidString(v) {
		return b, errInvalidUTF8{}
	}
	return b, nil
}

// consumeStringIfaceValidateUTF8 decodes a string value as a String.
func consumeStringIfaceValidateUTF8(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.BytesType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeString(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	if !utf8.ValidString(v) {
		return nil, 0, errInvalidUTF8{}
	}
	return v, n, nil
}

var coderStringIfaceValidateUTF8 = ifaceCoderFuncs{
	size:      sizeStringIface,
	marshal:   appendStringIfaceValidateUTF8,
	unmarshal: consumeStringIfaceValidateUTF8,
}

// sizeStringSliceIface returns the size of wire encoding a []string value as a repeated String.
func sizeStringSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[]string)
	for _, v := range s {
		size += tagsize + wire.SizeBytes(len(v))
	}
	return size
}

// appendStringSliceIface encodes a []string value as a repeated String.
func appendStringSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[]string)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendString(b, v)
	}
	return b, nil
}

// consumeStringSliceIface wire decodes a []string value as a repeated String.
func consumeStringSliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[]string)
	if wtyp != wire.BytesType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeString(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, v)
	return ival, n, nil
}

var coderStringSliceIface = ifaceCoderFuncs{
	size:      sizeStringSliceIface,
	marshal:   appendStringSliceIface,
	unmarshal: consumeStringSliceIface,
}

// sizeBytes returns the size of wire encoding a []byte pointer as a Bytes.
func sizeBytes(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Bytes()
	return tagsize + wire.SizeBytes(len(v))
}

// appendBytes wire encodes a []byte pointer as a Bytes.
func appendBytes(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Bytes()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendBytes(b, v)
	return b, nil
}

// consumeBytes wire decodes a []byte pointer as a Bytes.
func consumeBytes(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeBytes(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*p.Bytes() = append(([]byte)(nil), v...)
	return n, nil
}

var coderBytes = pointerCoderFuncs{
	size:      sizeBytes,
	marshal:   appendBytes,
	unmarshal: consumeBytes,
}

// appendBytesValidateUTF8 wire encodes a []byte pointer as a Bytes.
func appendBytesValidateUTF8(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Bytes()
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendBytes(b, v)
	if !utf8.Valid(v) {
		return b, errInvalidUTF8{}
	}
	return b, nil
}

// consumeBytesValidateUTF8 wire decodes a []byte pointer as a Bytes.
func consumeBytesValidateUTF8(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeBytes(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	if !utf8.Valid(v) {
		return 0, errInvalidUTF8{}
	}
	*p.Bytes() = append(([]byte)(nil), v...)
	return n, nil
}

var coderBytesValidateUTF8 = pointerCoderFuncs{
	size:      sizeBytes,
	marshal:   appendBytesValidateUTF8,
	unmarshal: consumeBytesValidateUTF8,
}

// sizeBytesNoZero returns the size of wire encoding a []byte pointer as a Bytes.
// The zero value is not encoded.
func sizeBytesNoZero(p pointer, tagsize int, _ marshalOptions) (size int) {
	v := *p.Bytes()
	if len(v) == 0 {
		return 0
	}
	return tagsize + wire.SizeBytes(len(v))
}

// appendBytesNoZero wire encodes a []byte pointer as a Bytes.
// The zero value is not encoded.
func appendBytesNoZero(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Bytes()
	if len(v) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendBytes(b, v)
	return b, nil
}

var coderBytesNoZero = pointerCoderFuncs{
	size:      sizeBytesNoZero,
	marshal:   appendBytesNoZero,
	unmarshal: consumeBytes,
}

// appendBytesNoZeroValidateUTF8 wire encodes a []byte pointer as a Bytes.
// The zero value is not encoded.
func appendBytesNoZeroValidateUTF8(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := *p.Bytes()
	if len(v) == 0 {
		return b, nil
	}
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendBytes(b, v)
	if !utf8.Valid(v) {
		return b, errInvalidUTF8{}
	}
	return b, nil
}

var coderBytesNoZeroValidateUTF8 = pointerCoderFuncs{
	size:      sizeBytesNoZero,
	marshal:   appendBytesNoZeroValidateUTF8,
	unmarshal: consumeBytesValidateUTF8,
}

// sizeBytesSlice returns the size of wire encoding a [][]byte pointer as a repeated Bytes.
func sizeBytesSlice(p pointer, tagsize int, _ marshalOptions) (size int) {
	s := *p.BytesSlice()
	for _, v := range s {
		size += tagsize + wire.SizeBytes(len(v))
	}
	return size
}

// appendBytesSlice encodes a [][]byte pointer as a repeated Bytes.
func appendBytesSlice(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.BytesSlice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendBytes(b, v)
	}
	return b, nil
}

// consumeBytesSlice wire decodes a [][]byte pointer as a repeated Bytes.
func consumeBytesSlice(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.BytesSlice()
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeBytes(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	*sp = append(*sp, append(([]byte)(nil), v...))
	return n, nil
}

var coderBytesSlice = pointerCoderFuncs{
	size:      sizeBytesSlice,
	marshal:   appendBytesSlice,
	unmarshal: consumeBytesSlice,
}

// appendBytesSliceValidateUTF8 encodes a [][]byte pointer as a repeated Bytes.
func appendBytesSliceValidateUTF8(b []byte, p pointer, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *p.BytesSlice()
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendBytes(b, v)
		if !utf8.Valid(v) {
			return b, errInvalidUTF8{}
		}
	}
	return b, nil
}

// consumeBytesSliceValidateUTF8 wire decodes a [][]byte pointer as a repeated Bytes.
func consumeBytesSliceValidateUTF8(b []byte, p pointer, wtyp wire.Type, _ unmarshalOptions) (n int, err error) {
	sp := p.BytesSlice()
	if wtyp != wire.BytesType {
		return 0, errUnknown
	}
	v, n := wire.ConsumeBytes(b)
	if n < 0 {
		return 0, wire.ParseError(n)
	}
	if !utf8.Valid(v) {
		return 0, errInvalidUTF8{}
	}
	*sp = append(*sp, append(([]byte)(nil), v...))
	return n, nil
}

var coderBytesSliceValidateUTF8 = pointerCoderFuncs{
	size:      sizeBytesSlice,
	marshal:   appendBytesSliceValidateUTF8,
	unmarshal: consumeBytesSliceValidateUTF8,
}

// sizeBytesIface returns the size of wire encoding a []byte value as a Bytes.
func sizeBytesIface(ival interface{}, tagsize int, _ marshalOptions) int {
	v := ival.([]byte)
	return tagsize + wire.SizeBytes(len(v))
}

// appendBytesIface encodes a []byte value as a Bytes.
func appendBytesIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.([]byte)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendBytes(b, v)
	return b, nil
}

// consumeBytesIface decodes a []byte value as a Bytes.
func consumeBytesIface(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.BytesType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeBytes(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	return append(([]byte)(nil), v...), n, nil
}

var coderBytesIface = ifaceCoderFuncs{
	size:      sizeBytesIface,
	marshal:   appendBytesIface,
	unmarshal: consumeBytesIface,
}

// appendBytesIfaceValidateUTF8 encodes a []byte value as a Bytes.
func appendBytesIfaceValidateUTF8(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	v := ival.([]byte)
	b = wire.AppendVarint(b, wiretag)
	b = wire.AppendBytes(b, v)
	if !utf8.Valid(v) {
		return b, errInvalidUTF8{}
	}
	return b, nil
}

// consumeBytesIfaceValidateUTF8 decodes a []byte value as a Bytes.
func consumeBytesIfaceValidateUTF8(b []byte, _ interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (interface{}, int, error) {
	if wtyp != wire.BytesType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeBytes(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	if !utf8.Valid(v) {
		return nil, 0, errInvalidUTF8{}
	}
	return append(([]byte)(nil), v...), n, nil
}

var coderBytesIfaceValidateUTF8 = ifaceCoderFuncs{
	size:      sizeBytesIface,
	marshal:   appendBytesIfaceValidateUTF8,
	unmarshal: consumeBytesIfaceValidateUTF8,
}

// sizeBytesSliceIface returns the size of wire encoding a [][]byte value as a repeated Bytes.
func sizeBytesSliceIface(ival interface{}, tagsize int, _ marshalOptions) (size int) {
	s := *ival.(*[][]byte)
	for _, v := range s {
		size += tagsize + wire.SizeBytes(len(v))
	}
	return size
}

// appendBytesSliceIface encodes a [][]byte value as a repeated Bytes.
func appendBytesSliceIface(b []byte, ival interface{}, wiretag uint64, _ marshalOptions) ([]byte, error) {
	s := *ival.(*[][]byte)
	for _, v := range s {
		b = wire.AppendVarint(b, wiretag)
		b = wire.AppendBytes(b, v)
	}
	return b, nil
}

// consumeBytesSliceIface wire decodes a [][]byte value as a repeated Bytes.
func consumeBytesSliceIface(b []byte, ival interface{}, _ wire.Number, wtyp wire.Type, _ unmarshalOptions) (_ interface{}, n int, err error) {
	sp := ival.(*[][]byte)
	if wtyp != wire.BytesType {
		return nil, 0, errUnknown
	}
	v, n := wire.ConsumeBytes(b)
	if n < 0 {
		return nil, 0, wire.ParseError(n)
	}
	*sp = append(*sp, append(([]byte)(nil), v...))
	return ival, n, nil
}

var coderBytesSliceIface = ifaceCoderFuncs{
	size:      sizeBytesSliceIface,
	marshal:   appendBytesSliceIface,
	unmarshal: consumeBytesSliceIface,
}

var wireTypes = map[protoreflect.Kind]wire.Type{
	protoreflect.BoolKind:     wire.VarintType,
	protoreflect.EnumKind:     wire.VarintType,
	protoreflect.Int32Kind:    wire.VarintType,
	protoreflect.Sint32Kind:   wire.VarintType,
	protoreflect.Uint32Kind:   wire.VarintType,
	protoreflect.Int64Kind:    wire.VarintType,
	protoreflect.Sint64Kind:   wire.VarintType,
	protoreflect.Uint64Kind:   wire.VarintType,
	protoreflect.Sfixed32Kind: wire.Fixed32Type,
	protoreflect.Fixed32Kind:  wire.Fixed32Type,
	protoreflect.FloatKind:    wire.Fixed32Type,
	protoreflect.Sfixed64Kind: wire.Fixed64Type,
	protoreflect.Fixed64Kind:  wire.Fixed64Type,
	protoreflect.DoubleKind:   wire.Fixed64Type,
	protoreflect.StringKind:   wire.BytesType,
	protoreflect.BytesKind:    wire.BytesType,
	protoreflect.MessageKind:  wire.BytesType,
	protoreflect.GroupKind:    wire.StartGroupType,
}
