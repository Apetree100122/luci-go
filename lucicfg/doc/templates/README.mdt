# LUCI configuration definition language

{{/* Renders documentation for all functions in the given struct. */}}
{{define "gen-funcs-doc"}}
{{.Doc.Description | LinkifySymbols }}

{{range $sym := .Symbols "func"}}
### {{.FullName}} {#{{$sym.Anchor}}}

```python
{{$sym.InvocationSnippet}}
```

{{if $sym.HasDocTag "advanced"}}
*** note
**Advanced function.** It is not used for common use cases.
***
{{end}}

{{$sym.Doc.Description | LinkifySymbols}}
{{if $sym.Doc.Args}}
#### Arguments {#{{$sym.Anchor "args"}}}
{{range $sym.Doc.Args}}
* **{{.Name | EscapeMD}}**: {{.Desc | LinkifySymbols}}
{{- end}}
{{- end}}

{{if $sym.Doc.Returns}}
#### Returns  {#{{$sym.Anchor "returns"}}}

{{$sym.Doc.Returns | LinkifySymbols}}
{{end}}

{{end}}
{{end}}


{{/* Renders TODO note. */}}
{{define "todo"}}
*** note
TODO: To be written.
***
{{end}}


{{/*
  Load all symbols we are going to document in advance to let LinkifySymbols
  know that they can be referred to through anchors.
*/}}
{{ $lucicfg := Symbol "@stdlib//builtins.star" "lucicfg" }}
{{ $io := Symbol "@stdlib//builtins.star" "io" }}
{{ $time := Symbol "@stdlib//builtins.star" "time" }}
{{ $luci := Symbol "@stdlib//builtins.star" "luci" }}
{{ $acl := Symbol "@stdlib//builtins.star" "acl" }}
{{ $swarming := Symbol "@stdlib//builtins.star" "swarming" }}
{{ $scheduler := Symbol "@stdlib//builtins.star" "scheduler" }}
{{ $cq := Symbol "@stdlib//builtins.star" "cq" }}
{{ $native := Symbol "@stdlib//native_doc.star" "" }}
{{ $proto := Symbol "@stdlib//proto_doc.star" "proto" }}


[TOC]

## Overview

`lucicfg` is a tool for generating low-level LUCI configuration files based on a
high-level configuration given as a [Starlark] script that uses APIs exposed by
`lucicfg`. In other words, it takes a \*.star file (or files) as input and
spits out a bunch of \*.cfg files (such us `cr-buildbucket.cfg` and
`luci-scheduler.cfg`) as outputs. A single entity (such as a
{{LinkifySymbols "luci.builder(...)"}} definition) in the input is translated
into multiple entities (such as Buildbucket's builder{...} and Scheduler's
job{...}) in the output. This ensures internal consistency of all low-level
configs.

Using Starlark allows to further reduce duplication and enforce invariants in
the configs. A common pattern is to use Starlark functions that wrap one or
more basic rules (e.g. {{LinkifySymbols "luci.builder(...)"}} and
{{LinkifySymbols "luci.console_view_entry(...)"}}) to define more "concrete"
entities (for example "a CI builder" or "a Try builder"). The rest of the
config script then uses such functions to build up the actual configuration.

### Getting lucicfg

`lucicfg` is distributed as a single self-contained binary as part of
[depot_tools], so if you use them, you already have it. Additionally it is
available in PATH on all LUCI builders. The rest of this doc also assumes that
`lucicfg` is in PATH.

If you don't use depot_tools, `lucicfg` can be installed through CIPD. The
package is [infra/tools/luci/lucicfg/${platform}], and the canonical stable
version can be looked up in the depot_tools [CIPD manifest].

Finally, you can always try to build `lucicfg` from the source code. However,
the only officially supported distribution mechanism is CIPD packages.

### Getting started with a simple config

*** note
More examples of using `lucicfg` can be found [here](../examples).
***

Create a new directory, create a new `main.star` file there with the following
content:

```python
#!/usr/bin/env lucicfg

luci.project(
    name = "hello-world",
    buildbucket = "cr-buildbucket.appspot.com",
    swarming = "chromium-swarm.appspot.com",
)

luci.bucket(name = "my-bucket")

luci.builder(
    name = "my-builder",
    bucket = "my-bucket",
    executable = luci.recipe(
        name = "my-recipe",
        cipd_package = "recipe/bundle/package",
    ),
)
```

Now run `lucicfg generate main.star`. It will create a new directory `generated`
side-by-side with `main.star` file. This directory contains `project.cfg` and
`cr-buildbucket.cfg` files, generated based on the script above.

Equivalently, make the script executable (`chmod a+x main.star`) and then just
execute it (`./main.star`). This is the exact same thing as running `generate`
subcommand.

Now make some change in `main.star` (for example, rename the builder), but do
not regenerate the configs yet. Instead run `lucicfg validate main.star`. It
will produce an error, telling you that files on disk (in `generated/*`) are
stale. Regenerate them (`./main.star`), and run the validation again.

If you have never done this before or haven't used any other LUCI tools, you are
now asked to authenticate by running `lucicfg auth-login`. This is because
`lucicfg validate` in addition to checking configs locally also sends them for a
more thorough validation to the LUCI Config service, and this requires you to be
authenticated. Do `lucicfg auth-login` and re-run `lucicfg validate main.star`.
It should succeed now. If it still fails with permissions issues, you are
probably not in `config-validation` group (this should be rare, please contact
luci-eng@google.com if this is happening).

`lucicfg validate` is meant to be used from presubmit tests. If you use
depot_tools' `PRESUBMIT.py`, there's a [canned check] that wraps
`lucicfg validate`.

This is it, your first generated config! It is not very functional yet (e.g.
builders without Swarming dimensions are useless), but a good place to start.
Keep iterating on it, modifying the script, regenerating configs, and examining
the output in `generated` directory. Once you are satisfied with the result,
commit **both** Starlark scripts and generated configs into the repository, and
then configure LUCI Config service to pull configuration from `generated`
directory (how to do it is outside the scope of this doc).

### Migrating from existing configs to lucicfg

{{template "todo"}}

[Starlark]: https://github.com/google/starlark-go
[depot_tools]: https://chromium.googlesource.com/chromium/tools/depot_tools/
[infra/tools/luci/lucicfg/${platform}]: https://chrome-infra-packages.appspot.com/p/infra/tools/luci/lucicfg
[CIPD manifest]: https://chromium.googlesource.com/chromium/tools/depot_tools/+/refs/heads/master/cipd_manifest.txt
[canned check]: https://chromium.googlesource.com/chromium/tools/depot_tools/+/39b0b8e32a4ed0675a38d97799e8a219cc549910/presubmit_canned_checks.py#1437


## Concepts

### Execution model {#execution_doc}
{{template "todo"}}

### Rules, nodes, relations
{{template "todo"}}

### Resolving naming ambiguities
{{template "todo"}}


### Defining cron schedules {#schedules_doc}

{{LinkifySymbols "luci.builder(...)"}} and
{{LinkifySymbols "luci.gitiles_poller(...)"}} rules have `schedule` field that
defines how often the builder or poller should run. Schedules are given as
strings. Supported kinds of schedules (illustrated via examples):

  - `* 0 * * * *`: a crontab expression, in a syntax supported by
    https://github.com/gorhill/cronexpr (see its docs for full reference).
    LUCI will attempt to start the job at specified moments in time (based on
    **UTC clock**). Some examples:
      - `0 */3 * * * *` - every 3 hours: at 12:00 AM UTC, 3:00 AM UTC, ...
      - `0 */3 * * *` - the exact same thing (the last field is optional).
      - `0 1/3 * * *` - every 3 hours but starting 1:00 AM UTC.
      - `0 2,10,18 * * *` - at 2 AM UTC, 10 AM UTC, 6 PM UTC.
      - `0 7 * * *` - at 7 AM UTC, once a day.

    If a previous invocation is still running when triggering a new one,
    an overrun is recorded and the new scheduled invocation is skipped. The next
    attempt to start the job happens based on the schedule (not when the
    currently running invocation finishes).

  - `with 10s interval`: run the job in a loop, waiting 10s after finishing
     an invocation before starting a new one. Moments when the job starts aren't
     synchronized with the wall clock at all.

  - `with 1m interval`, `with 1h interval`: same format, just using minutes and
    hours instead of seconds.

  - `continuously` is alias for `with 0s interval`, meaning to run the job in
    a loop without any pauses at all.

  - `triggered` schedule indicates that the job is only started via some
    external triggering event (e.g. via LUCI Scheduler API), not periodically.
      - in {{LinkifySymbols "luci.builder(...)"}} this schedule is useful to
        make lucicfg setup a scheduler job associated with the builder (even if
        the builder is not triggered by anything else in the configs). This
        exposes the builder in LUCI Scheduler API.
      - in {{LinkifySymbols "luci.gitiles_poller(...)"}} this is useful to setup
        a poller that polls only on manual requests, not periodically.


## Interfacing with lucicfg internals
{{template "gen-funcs-doc" $lucicfg}}

## Working with time
{{template "gen-funcs-doc" $time}}

## Core LUCI rules
{{template "gen-funcs-doc" $luci}}

## ACLs

### Roles {#roles_doc}

Below is the table with role constants that can be passed as `roles` in
{{LinkifySymbols "acl.entry(...)"}}.

Due to some inconsistencies in how LUCI service are currently implemented, some
roles can be assigned only in {{LinkifySymbols "luci.project(...)"}} rule, but
some also in individual {{LinkifySymbols "luci.bucket(...)"}} or
{{LinkifySymbols "luci.cq_group(...)"}} rules.

Similarly some roles can be assigned to individual users, other only to groups.

| Role  | Scope | Principals | Allows |
|-------|-------|------------|--------|
{{- range $sym := $acl.Symbols "inv"}}
| {{.FullName}} |
{{- if .HasDocTag "project_level_only"}}project only{{else if .HasDocTag "cq_role"}}project, cq_group{{else}}project, bucket{{end}} |
{{- if .HasDocTag "groups_only"}}groups{{else}}groups, users{{end}} |
{{- .Doc.Description | LinkifySymbols}} |
{{- end}}

{{template "gen-funcs-doc" $acl}}

## Swarming
{{template "gen-funcs-doc" $swarming}}

## Scheduler
{{template "gen-funcs-doc" $scheduler}}

## CQ  {#cq_doc}
{{template "gen-funcs-doc" $cq}}

## Built-in constants and functions

Refer to the list of [built-in constants and functions][starlark-builtins]
exposed in the global namespace by Starlark itself.

[starlark-builtins]: https://github.com/google/starlark-go/blob/master/doc/spec.md#built-in-constants-and-functions

In addition, `lucicfg` exposes the following functions.

{{template "gen-funcs-doc" $native}}
{{template "gen-funcs-doc" $proto}}
{{template "gen-funcs-doc" $io}}
