// Code generated by protoc-gen-go. DO NOT EDIT.
// source: components/auth/proto/realms.proto

package protocol

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Realms is a complete definition of all known permissions and realms in a LUCI
// deployment.
//
// It is generated and distributed across all LUCI services (as part of the
// AuthDB) by the LUCI Auth service.
//
// Note that this is a denormalized internal representation of realms which is
// derived from the high level user-facing representation (supplied by users via
// realms.cfg project configs). In particular, the internal representation
// doesn't have a notion of roles or realm inheritance. These concepts are
// handled by the LUCI Auth service and individual downstream services generally
// **must not care** how it works. Instead they should follow the rules outlined
// in comments in this file (or equivalently just use the Realms API exposed by
// the LUCI auth libraries).
type Realms struct {
	// API version is incremented whenever the semantic meaning of Realms message
	// changes in some backward incompatible way (e.g. some message grows a new
	// field that *must* be checked by services). LUCI services must reject Realms
	// messages that have API versions they don't recognize. It is a precaution
	// against misinterpreting the realms configuration.
	//
	// The current version is 1.
	ApiVersion int64 `protobuf:"varint,1,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	// List of all possible permissions in alphabetical order.
	//
	// Acts as a universal set of permissions in Binding messages.
	//
	// Services may also use this field to check that permissions they are about
	// to use are actually known to the LUCI auth system. This is useful for
	// debugging when adding or removing permissions.
	//
	// See Permission message for more details.
	Permissions []*Permission `protobuf:"bytes,2,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// List of all registered realms in alphabetical order.
	//
	// See Realm message for more details.
	Realms               []*Realm `protobuf:"bytes,3,rep,name=realms,proto3" json:"realms,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Realms) Reset()         { *m = Realms{} }
func (m *Realms) String() string { return proto.CompactTextString(m) }
func (*Realms) ProtoMessage()    {}
func (*Realms) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75e848ad8b68fa2, []int{0}
}

func (m *Realms) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Realms.Unmarshal(m, b)
}
func (m *Realms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Realms.Marshal(b, m, deterministic)
}
func (m *Realms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Realms.Merge(m, src)
}
func (m *Realms) XXX_Size() int {
	return xxx_messageInfo_Realms.Size(m)
}
func (m *Realms) XXX_DiscardUnknown() {
	xxx_messageInfo_Realms.DiscardUnknown(m)
}

var xxx_messageInfo_Realms proto.InternalMessageInfo

func (m *Realms) GetApiVersion() int64 {
	if m != nil {
		return m.ApiVersion
	}
	return 0
}

func (m *Realms) GetPermissions() []*Permission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Realms) GetRealms() []*Realm {
	if m != nil {
		return m.Realms
	}
	return nil
}

// Permission is a symbol that has form "<service>.<subject>.<verb>", which
// describes some elementary action ("<verb>") that can be done to some category
// of resources ("<subject>"), managed by some particular kind of LUCI service
// ("<service>").
//
// Within each individual realm (see Realm message), a principal (such as an end
// user or a service account) can have zero or more permissions that describe
// what this user can actually do to resources belonging to the realm. See Realm
// message for the definition of what "belonging to the realm" means.
//
// Examples of permissions:
//   * buildbucket.build.create
//   * swarming.pool.listBots
//   * swarming.task.cancel
//
// Note that permission names are composed of generic terms, not some specific
// IDs of service deployments or resources. Generally, using a concrete
// permission name in the service's source code as a constant should look
// natural.
//
// Each individual LUCI service should document what permissions it checks and
// when. It becomes a part of service's public API. Usually services should
// check only permissions of resources they own (e.g. "<service>.<subject>.*"),
// but in exceptional cases they may also check permissions intended for other
// services. This is primarily useful for services that somehow "proxy" access
// to resources.
//
// Field `permissions` in Realms message describes all permissions known to the
// LUCI Auth service. The LUCI Auth service guarantees that all permissions
// mentioned in all realms (in `realms` field) are among `permissions` set.
//
// If a LUCI service checks a permission that is no longer (or not yet) listed
// in the `permissions` set, the check should succeed with "no permission"
// result, and produce a warning in service's logs.
//
// Note that Permission is a proto message (and not just a string) to allow
// attaching metadata to permissions in the future (for example "deprecated"
// flag).
type Permission struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Permission) Reset()         { *m = Permission{} }
func (m *Permission) String() string { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()    {}
func (*Permission) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75e848ad8b68fa2, []int{1}
}

func (m *Permission) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Permission.Unmarshal(m, b)
}
func (m *Permission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Permission.Marshal(b, m, deterministic)
}
func (m *Permission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Permission.Merge(m, src)
}
func (m *Permission) XXX_Size() int {
	return xxx_messageInfo_Permission.Size(m)
}
func (m *Permission) XXX_DiscardUnknown() {
	xxx_messageInfo_Permission.DiscardUnknown(m)
}

var xxx_messageInfo_Permission proto.InternalMessageInfo

func (m *Permission) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Realm is a named collection of (<principal>, <permission>) pairs.
//
// A realm name has form "<project>/<realm>", where "<project>" is a name of
// the LUCI project that defined the realm, and "<realm>" is a user-provided
// name of the realm from realms.cfg project config file.
//
// A LUCI resource can point to exactly one realm by referring to its
// "<project>/<realm>" name. Such reference can either be calculated on the fly
// from other resource's properties, or be stored alongside the resource's data.
// We say that such resource "belongs to the realm" or "lives in the realm" or
// is just "in the realm". We also say that such resource belongs to the project
// "<project>". The corresponding Realm message then describes who can do what
// to the resource.
//
// The logic of how resources get assigned to realms is a part of the public API
// of the service that owns resources. Some services may use a static realm
// assignment via project configuration files, others may do it dynamically by
// accepting a realm when a resource is created via an RPC.
//
// There are two special realms (both optional) that a project can have:
// "<project>/@root" and "<project>/@legacy".
//
// The root realm should be used as a fallback when an existing resource points
// to a realm that doesn't exist. Without the root realm, such resources become
// effectively inaccessible and this may be undesirable. The root realm usually
// contains only administrative-level bindings.
//
// The legacy realm should be used for legacy resources created before the
// realms mechanism was introduced in case the service can't figure out a more
// appropriate realm based on resource's properties. The service must clearly
// document when and how it uses the legacy realm (if it uses it at all).
//
// The actual list of (<principal>, <permission>) pairs is defined via a list of
// bindings, where each binding basically says "all these principals have all
// these permissions". In other words, each binding defines some subset of
// permissions and the overall realm permissions is a union of all such subsets.
// Subsets defined by bindings may potentially intersect or be empty.
//
// The LUCI Auth service constructs bindings by interpreting realms.cfg project
// configuration file using some set of rules. Individual LUCI services **must
// not care** about what these rules really are. They should use only the end
// result (in the form of bindings) provided in the Realm message. This allows
// to decouple the high-level user-facing language for defining permissions from
// the implementation of each individual LUCI service that checks permissions.
type Realm struct {
	// Name of the realm as "<project>/<realm>" string, where:
	//   "<project>" is a LUCI project name, matches `^[a-z0-9\-_]{1,100}$`.
	//   "<realm>" matches `^[a-z0-9_\.\-/]{1,400}|@root|@legacy$`.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// A list of bindings in lexicographical order of their `permissions` fields.
	Bindings             []*Binding `protobuf:"bytes,2,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Realm) Reset()         { *m = Realm{} }
func (m *Realm) String() string { return proto.CompactTextString(m) }
func (*Realm) ProtoMessage()    {}
func (*Realm) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75e848ad8b68fa2, []int{2}
}

func (m *Realm) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Realm.Unmarshal(m, b)
}
func (m *Realm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Realm.Marshal(b, m, deterministic)
}
func (m *Realm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Realm.Merge(m, src)
}
func (m *Realm) XXX_Size() int {
	return xxx_messageInfo_Realm.Size(m)
}
func (m *Realm) XXX_DiscardUnknown() {
	xxx_messageInfo_Realm.DiscardUnknown(m)
}

var xxx_messageInfo_Realm proto.InternalMessageInfo

func (m *Realm) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Realm) GetBindings() []*Binding {
	if m != nil {
		return m.Bindings
	}
	return nil
}

// Binding assigns all specified permissions to all specified principals.
type Binding struct {
	// Permissions in increasing order of their indexes.
	//
	// This set is a subset of `permissions` in the Realms message. Each element
	// is an index of a permission in the `permissions` list in the Realms
	// message.
	//
	// These indexes are not stable across different copies of Realms message.
	// They must not be stored or processed in isolation from the containing
	// Realms message.
	Permissions []uint32 `protobuf:"varint,1,rep,packed,name=permissions,proto3" json:"permissions,omitempty"`
	// A set of principals to grant all above permissions to.
	//
	// Each entry can either be an identity string (like "user:<email>") or a
	// LUCI group reference "group:<name>".
	//
	// Ordered alphabetically.
	Principals           []string `protobuf:"bytes,2,rep,name=principals,proto3" json:"principals,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Binding) Reset()         { *m = Binding{} }
func (m *Binding) String() string { return proto.CompactTextString(m) }
func (*Binding) ProtoMessage()    {}
func (*Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_a75e848ad8b68fa2, []int{3}
}

func (m *Binding) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Binding.Unmarshal(m, b)
}
func (m *Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Binding.Marshal(b, m, deterministic)
}
func (m *Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binding.Merge(m, src)
}
func (m *Binding) XXX_Size() int {
	return xxx_messageInfo_Binding.Size(m)
}
func (m *Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Binding proto.InternalMessageInfo

func (m *Binding) GetPermissions() []uint32 {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Binding) GetPrincipals() []string {
	if m != nil {
		return m.Principals
	}
	return nil
}

func init() {
	proto.RegisterType((*Realms)(nil), "components.auth.realms.Realms")
	proto.RegisterType((*Permission)(nil), "components.auth.realms.Permission")
	proto.RegisterType((*Realm)(nil), "components.auth.realms.Realm")
	proto.RegisterType((*Binding)(nil), "components.auth.realms.Binding")
}

func init() {
	proto.RegisterFile("components/auth/proto/realms.proto", fileDescriptor_a75e848ad8b68fa2)
}

var fileDescriptor_a75e848ad8b68fa2 = []byte{
	// 277 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0x3d, 0x4f, 0xc3, 0x30,
	0x10, 0x86, 0x15, 0x02, 0x85, 0x5e, 0xc4, 0xe2, 0x01, 0x65, 0x81, 0x46, 0x9e, 0x32, 0x39, 0x12,
	0x88, 0x85, 0x32, 0x55, 0x6c, 0x2c, 0xc8, 0x03, 0x42, 0x2c, 0xc8, 0x35, 0x56, 0x7a, 0x52, 0xfc,
	0x21, 0x3b, 0xe9, 0x4f, 0xe2, 0x77, 0xa2, 0xd8, 0xfd, 0x94, 0xda, 0xed, 0xbd, 0xbb, 0xe7, 0xde,
	0x3b, 0xfb, 0x80, 0x4a, 0xab, 0x9d, 0x35, 0xca, 0xf4, 0xa1, 0x11, 0x43, 0xbf, 0x6a, 0x9c, 0xb7,
	0xbd, 0x6d, 0xbc, 0x12, 0x9d, 0x0e, 0x2c, 0x06, 0xe4, 0x6e, 0xcf, 0xb0, 0x91, 0x61, 0xa9, 0x4a,
	0xff, 0x32, 0x98, 0xf0, 0x28, 0xc9, 0x0c, 0x0a, 0xe1, 0xf0, 0x67, 0xad, 0x7c, 0x40, 0x6b, 0xca,
	0xac, 0xca, 0xea, 0x9c, 0x83, 0x70, 0xf8, 0x99, 0x32, 0xe4, 0x0d, 0x0a, 0xa7, 0xbc, 0xc6, 0x30,
	0x46, 0xa1, 0xbc, 0xa8, 0xf2, 0xba, 0x78, 0xa4, 0xec, 0xb4, 0x33, 0xfb, 0xd8, 0xa1, 0xfc, 0xb0,
	0x8d, 0x3c, 0xc3, 0x24, 0x11, 0x65, 0x1e, 0x0d, 0xee, 0xcf, 0x19, 0xc4, 0xb5, 0xf8, 0x06, 0xa6,
	0x15, 0xc0, 0xde, 0x91, 0x10, 0xb8, 0x34, 0x42, 0xab, 0xb8, 0xe4, 0x94, 0x47, 0x4d, 0xbf, 0xe0,
	0x2a, 0xb6, 0x9c, 0x2a, 0x92, 0x39, 0xdc, 0x2c, 0xd1, 0xfc, 0xa2, 0x69, 0xb7, 0x8b, 0xcf, 0xce,
	0xcd, 0x5d, 0x24, 0x8e, 0xef, 0x1a, 0xe8, 0x3b, 0x5c, 0x6f, 0x92, 0xa4, 0x3a, 0xfe, 0x83, 0xac,
	0xca, 0xeb, 0xdb, 0xe3, 0xf7, 0x3d, 0x00, 0x38, 0x8f, 0x46, 0xa2, 0x13, 0x5d, 0x9a, 0x35, 0xe5,
	0x07, 0x99, 0xc5, 0xeb, 0xf7, 0x4b, 0x6b, 0x99, 0x5c, 0x79, 0xab, 0x71, 0xd0, 0xcc, 0xfa, 0xb6,
	0xe9, 0x06, 0x89, 0x4d, 0x50, 0x7e, 0xad, 0x7c, 0x3a, 0xe0, 0xa8, 0x51, 0xaa, 0x74, 0x48, 0x69,
	0xbb, 0xf9, 0x56, 0x2c, 0x27, 0x51, 0x3d, 0xfd, 0x07, 0x00, 0x00, 0xff, 0xff, 0x20, 0x0f, 0xc3,
	0xa0, 0xf4, 0x01, 0x00, 0x00,
}
