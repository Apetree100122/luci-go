// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/common/proto/realms/realms_config.proto

package realms

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "go.chromium.org/luci/common/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// RealmsCfg defines a schema for realms.cfg project configuration file.
type RealmsCfg struct {
	// List of all realms in the project in arbitrary order.
	Realms []*Realm `protobuf:"bytes,1,rep,name=realms,proto3" json:"realms,omitempty"`
	// Optional list of custom roles that can be referenced from Bindings in this
	// project.
	CustomRoles          []*CustomRole `protobuf:"bytes,2,rep,name=custom_roles,json=customRoles,proto3" json:"custom_roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RealmsCfg) Reset()         { *m = RealmsCfg{} }
func (m *RealmsCfg) String() string { return proto.CompactTextString(m) }
func (*RealmsCfg) ProtoMessage()    {}
func (*RealmsCfg) Descriptor() ([]byte, []int) {
	return fileDescriptor_76cc0dadaf620b71, []int{0}
}

func (m *RealmsCfg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RealmsCfg.Unmarshal(m, b)
}
func (m *RealmsCfg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RealmsCfg.Marshal(b, m, deterministic)
}
func (m *RealmsCfg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RealmsCfg.Merge(m, src)
}
func (m *RealmsCfg) XXX_Size() int {
	return xxx_messageInfo_RealmsCfg.Size(m)
}
func (m *RealmsCfg) XXX_DiscardUnknown() {
	xxx_messageInfo_RealmsCfg.DiscardUnknown(m)
}

var xxx_messageInfo_RealmsCfg proto.InternalMessageInfo

func (m *RealmsCfg) GetRealms() []*Realm {
	if m != nil {
		return m.Realms
	}
	return nil
}

func (m *RealmsCfg) GetCustomRoles() []*CustomRole {
	if m != nil {
		return m.CustomRoles
	}
	return nil
}

// Realm is a named collection of (<principal>, <permission>) pairs.
//
// A LUCI resource can point to exactly one realm by referring to its full
// name ("<project>:<realm>"). We say that such resource "belongs to the realm"
// or "lives in the realm" or is just "in the realm". We also say that such
// resource belongs to the project "<project>". The corresponding Realm message
// then describes who can do what to the resource.
//
// The logic of how resources get assigned to realms is a part of the public API
// of the service that owns resources. Some services may use a static realm
// assignment via project configuration files, others may do it dynamically by
// accepting a realm when a resource is created via an RPC.
//
// A realm can "extend" one or more other realms. If a realm `A` extends `B`,
// then all permissions defined in `B` are also in `A`. Remembering that a realm
// is just a set of (<principal>, <permission>) pairs, the "extend" relation is
// just a set inclusion.
//
// The primary way of populating the permission set of a realm is via bindings.
// Each binding assigns a role to a set of principals. Since each role is
// essentially just a set of permissions, each binding adds to the realm a
// Cartesian product of a set of permissions (defined via the role) and a set of
// principals (defined via a direct listing or via groups).
//
// There are two special realms (both optional) that a project can have: "@root"
// and "@legacy".
//
// The root realm is implicitly included into all other realms (including
// "@legacy"), and it is also used as a fallback when a resource points to
// a realm that no longer exists. Without the root realm, such resources become
// effectively inaccessible and this may be undesirable. Permissions in the root
// realm apply to all realms in the project (current, past and future), and thus
// the root realm should contain only administrative-level bindings. If you are
// not sure whether you should use the root realm or not, err on the side of not
// using it.
//
// The legacy realm is used for existing resources created before the realms
// mechanism was introduced. Such resources usually are not associated with any
// realm at all. They are implicitly placed into the legacy realm to allow
// reusing realms' machinery for them.
//
// Note that the details of how resources are placed in the legacy realm are up
// to a particular service implementation. Some services may be able to figure
// out an appropriate realm for a legacy resource based on resource's existing
// attributes. Some services may not have legacy resources at all. The legacy
// realm is not used in these case. Refer to the service documentation.
type Realm struct {
	// Name of the realm.
	//
	// Must match `^[a-z0-9_\.\-/]{1,400}$` or be literals "@root" or "@legacy".
	//
	// Realm names must be unique within a project.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional list of realms whose permissions will be included in this realm.
	//
	// All realms implicitly extend "@root" realm (if it is defined), i.e. all
	// permissions specified in the "@root" realm are propagated to all realms in
	// the project.
	//
	// To keep the mental model simple, cycles aren't allowed (i.e. a realm is not
	// allowed to directly or indirectly extend itself). The LUCI Config service
	// will reject realms.cfg that contains cycles during the config validation
	// phase.
	Extends []string `protobuf:"bytes,2,rep,name=extends,proto3" json:"extends,omitempty"`
	// List of bindings that define who can do what to resources in this realm.
	Bindings             []*Binding `protobuf:"bytes,3,rep,name=bindings,proto3" json:"bindings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Realm) Reset()         { *m = Realm{} }
func (m *Realm) String() string { return proto.CompactTextString(m) }
func (*Realm) ProtoMessage()    {}
func (*Realm) Descriptor() ([]byte, []int) {
	return fileDescriptor_76cc0dadaf620b71, []int{1}
}

func (m *Realm) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Realm.Unmarshal(m, b)
}
func (m *Realm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Realm.Marshal(b, m, deterministic)
}
func (m *Realm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Realm.Merge(m, src)
}
func (m *Realm) XXX_Size() int {
	return xxx_messageInfo_Realm.Size(m)
}
func (m *Realm) XXX_DiscardUnknown() {
	xxx_messageInfo_Realm.DiscardUnknown(m)
}

var xxx_messageInfo_Realm proto.InternalMessageInfo

func (m *Realm) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Realm) GetExtends() []string {
	if m != nil {
		return m.Extends
	}
	return nil
}

func (m *Realm) GetBindings() []*Binding {
	if m != nil {
		return m.Bindings
	}
	return nil
}

// Binding assigns a role to all specified principals.
type Binding struct {
	// Name of the role to assign.
	//
	// Can either be a predefined role (if starts with "role/") or a custom role
	// (if starts with "customRole/"). See TODO for a list of predefined roles
	// and their meanings.
	//
	// A custom role must be defined somewhere in this realms.cfg file.
	Role string `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	// A set of principals to assign the role to.
	//
	// Each entry can either be an identity string (like "user:<email>") or a
	// LUCI group reference "group:<name>".
	Principals           []string `protobuf:"bytes,2,rep,name=principals,proto3" json:"principals,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Binding) Reset()         { *m = Binding{} }
func (m *Binding) String() string { return proto.CompactTextString(m) }
func (*Binding) ProtoMessage()    {}
func (*Binding) Descriptor() ([]byte, []int) {
	return fileDescriptor_76cc0dadaf620b71, []int{2}
}

func (m *Binding) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Binding.Unmarshal(m, b)
}
func (m *Binding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Binding.Marshal(b, m, deterministic)
}
func (m *Binding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binding.Merge(m, src)
}
func (m *Binding) XXX_Size() int {
	return xxx_messageInfo_Binding.Size(m)
}
func (m *Binding) XXX_DiscardUnknown() {
	xxx_messageInfo_Binding.DiscardUnknown(m)
}

var xxx_messageInfo_Binding proto.InternalMessageInfo

func (m *Binding) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Binding) GetPrincipals() []string {
	if m != nil {
		return m.Principals
	}
	return nil
}

// Custom role defines a custom named set of permissions.
//
// Can be used in bindings if predefined roles are too broad or do not map well
// to the desired set of permissions.
//
// Custom roles are scoped to the project (i.e. different projects may have
// identically named, but semantically different custom roles).
type CustomRole struct {
	// Name of this custom role, must start with "customRole/".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional list of roles whose permissions will be included in this role.
	//
	// Each entry can either be a predefined role (if starts with "role/") or
	// another custom role defined in this realms.cfg (if starts with
	// "customRole/").
	//
	// To keep the mental model simple, cycles aren't allowed (i.e. a custom role
	// is not allowed to directly or indirectly extend itself). The LUCI Config
	// service will reject realms.cfg that contains cycles during the config
	// validation phase.
	Extends []string `protobuf:"bytes,2,rep,name=extends,proto3" json:"extends,omitempty"`
	// Optional list of permissions to include in the role.
	//
	// Each permission is a symbol that has form "<service>.<subject>.<verb>",
	// which describes some elementary action ("<verb>") that can be done to some
	// category of resources ("<subject>"), managed by some particular kind of
	// LUCI service ("<service>").
	//
	// Examples of permissions:
	//   * buildbucket.build.create
	//   * swarming.pool.listBots
	//   * swarming.task.cancel
	//
	// See TODO for a list of all possible permissions.
	Permissions          []string `protobuf:"bytes,3,rep,name=permissions,proto3" json:"permissions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CustomRole) Reset()         { *m = CustomRole{} }
func (m *CustomRole) String() string { return proto.CompactTextString(m) }
func (*CustomRole) ProtoMessage()    {}
func (*CustomRole) Descriptor() ([]byte, []int) {
	return fileDescriptor_76cc0dadaf620b71, []int{3}
}

func (m *CustomRole) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CustomRole.Unmarshal(m, b)
}
func (m *CustomRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CustomRole.Marshal(b, m, deterministic)
}
func (m *CustomRole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomRole.Merge(m, src)
}
func (m *CustomRole) XXX_Size() int {
	return xxx_messageInfo_CustomRole.Size(m)
}
func (m *CustomRole) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomRole.DiscardUnknown(m)
}

var xxx_messageInfo_CustomRole proto.InternalMessageInfo

func (m *CustomRole) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CustomRole) GetExtends() []string {
	if m != nil {
		return m.Extends
	}
	return nil
}

func (m *CustomRole) GetPermissions() []string {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func init() {
	proto.RegisterType((*RealmsCfg)(nil), "auth_service.RealmsCfg")
	proto.RegisterType((*Realm)(nil), "auth_service.Realm")
	proto.RegisterType((*Binding)(nil), "auth_service.Binding")
	proto.RegisterType((*CustomRole)(nil), "auth_service.CustomRole")
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/common/proto/realms/realms_config.proto", fileDescriptor_76cc0dadaf620b71)
}

var fileDescriptor_76cc0dadaf620b71 = []byte{
	// 335 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x52, 0xc1, 0x4e, 0xeb, 0x30,
	0x10, 0x54, 0x5f, 0x1f, 0x2d, 0xd9, 0xf6, 0x64, 0x84, 0x14, 0x71, 0x40, 0x55, 0xb8, 0x54, 0x42,
	0xd8, 0x02, 0x6e, 0x2d, 0xbd, 0xb4, 0x7f, 0xe0, 0x23, 0x42, 0xaa, 0x52, 0xd7, 0x4d, 0x8c, 0x62,
	0xaf, 0x65, 0x3b, 0x88, 0xef, 0xe1, 0x43, 0x11, 0x8a, 0x93, 0x96, 0xf6, 0x04, 0x9c, 0x76, 0x33,
	0x3b, 0x3b, 0xb3, 0xc9, 0x04, 0x9e, 0x0a, 0xa4, 0xa2, 0x74, 0xa8, 0x55, 0xad, 0x29, 0xba, 0x82,
	0x55, 0xb5, 0x50, 0x4c, 0xa0, 0xd6, 0x68, 0x98, 0x75, 0x18, 0x90, 0x39, 0x99, 0x57, 0xda, 0x77,
	0x65, 0x2d, 0xd0, 0xec, 0x54, 0x41, 0xe3, 0x88, 0x8c, 0xf3, 0x3a, 0x94, 0x6b, 0x2f, 0xdd, 0x9b,
	0x12, 0xf2, 0x8a, 0xfd, 0xac, 0x85, 0x36, 0x28, 0x34, 0xbe, 0x5d, 0xcf, 0x6a, 0x48, 0x78, 0x54,
	0x5d, 0xed, 0x0a, 0x72, 0x0b, 0x83, 0xd6, 0x22, 0xed, 0x4d, 0xfa, 0xd3, 0xd1, 0xc3, 0x05, 0x3d,
	0x16, 0xa7, 0x91, 0xc8, 0x3b, 0x0a, 0x99, 0xc3, 0x58, 0xd4, 0x3e, 0xa0, 0x5e, 0x3b, 0xac, 0xa4,
	0x4f, 0xff, 0xc5, 0x95, 0xf4, 0x74, 0x65, 0x15, 0x19, 0x1c, 0x2b, 0xc9, 0x47, 0xe2, 0xd0, 0xfb,
	0xac, 0x84, 0xb3, 0xa8, 0x46, 0x08, 0xfc, 0x37, 0xb9, 0x96, 0x69, 0x6f, 0xd2, 0x9b, 0x26, 0x3c,
	0xf6, 0x24, 0x85, 0xa1, 0x7c, 0x0f, 0xd2, 0x6c, 0x5b, 0xd1, 0x84, 0xef, 0x1f, 0xc9, 0x3d, 0x9c,
	0x6f, 0x94, 0xd9, 0x2a, 0x53, 0xf8, 0xb4, 0x1f, 0xfd, 0x2e, 0x4f, 0xfd, 0x96, 0xed, 0x94, 0x1f,
	0x68, 0xd9, 0x02, 0x86, 0x1d, 0xd8, 0x78, 0x35, 0xa7, 0xee, 0xbd, 0x9a, 0x9e, 0x5c, 0x03, 0x58,
	0xa7, 0x8c, 0x50, 0x36, 0xaf, 0xf6, 0x76, 0x47, 0x48, 0xf6, 0x02, 0xf0, 0xfd, 0x0e, 0x7f, 0xbc,
	0x76, 0x02, 0x23, 0x2b, 0x9d, 0x56, 0xde, 0x37, 0x1f, 0x3c, 0x1e, 0x9c, 0xf0, 0x63, 0x68, 0xe9,
	0x3e, 0x3e, 0x6f, 0x16, 0x30, 0x2f, 0x43, 0xb0, 0x7e, 0xc6, 0x62, 0x58, 0x77, 0x5d, 0xba, 0xb9,
	0xb5, 0xde, 0x62, 0xa0, 0x02, 0x35, 0xf3, 0xa2, 0x94, 0x3a, 0xf7, 0x4d, 0x80, 0xaf, 0x52, 0x04,
	0x3f, 0x6b, 0x23, 0xa0, 0x62, 0x57, 0x3c, 0xb3, 0xdf, 0xfe, 0x3d, 0xf3, 0xb6, 0x6c, 0x06, 0x11,
	0x7c, 0xfc, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x96, 0x99, 0x77, 0x28, 0x77, 0x02, 0x00, 0x00,
}
