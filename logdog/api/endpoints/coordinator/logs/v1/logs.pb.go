// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/logdog/api/endpoints/coordinator/logs/v1/logs.proto

package logdog

import prpc "go.chromium.org/luci/grpc/prpc"

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	logpb "go.chromium.org/luci/logdog/api/logpb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Trinary represents a trinary value.
type QueryRequest_Trinary int32

const (
	// Both positive and negative results will be returned.
	QueryRequest_BOTH QueryRequest_Trinary = 0
	// Only positive results will be returned.
	QueryRequest_YES QueryRequest_Trinary = 1
	// Only negative results will be returned.
	QueryRequest_NO QueryRequest_Trinary = 2
)

var QueryRequest_Trinary_name = map[int32]string{
	0: "BOTH",
	1: "YES",
	2: "NO",
}

var QueryRequest_Trinary_value = map[string]int32{
	"BOTH": 0,
	"YES":  1,
	"NO":   2,
}

func (x QueryRequest_Trinary) String() string {
	return proto.EnumName(QueryRequest_Trinary_name, int32(x))
}

func (QueryRequest_Trinary) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{3, 0}
}

// GetRequest is the request structure for the user Get endpoint.
//
// If the requested log stream exists, a valid GetRequest will succeed
// regardless of whether the requested log range was available.
//
// Note that this endpoint may return fewer logs than requested due to either
// availability or internal constraints.
type GetRequest struct {
	// The request project to request.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// The path of the log stream to get.
	//
	// This can either be a LogDog stream path or the SHA256 hash of a LogDog
	// stream path.
	//
	// Some utilities may find passing around a full LogDog path to be cumbersome
	// due to its length. They can opt to pass around the hash instead and
	// retrieve logs using it.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// If true, requests that the log stream's state is returned.
	State bool `protobuf:"varint,3,opt,name=state,proto3" json:"state,omitempty"`
	// The initial log stream index to retrieve.
	Index int64 `protobuf:"varint,4,opt,name=index,proto3" json:"index,omitempty"`
	// The maximum number of bytes to return. If non-zero, it is applied as a
	// constraint to limit the number of logs that are returned.
	//
	// This only returns complete logs. Assuming logs are available, it will
	// return at least one log (even if it violates the size constraint) and as
	// many additional logs as it can without exceeding this constraint.
	ByteCount int32 `protobuf:"varint,5,opt,name=byte_count,json=byteCount,proto3" json:"byte_count,omitempty"`
	// The maximum number of log records to request.
	//
	// If this value is zero, no count constraint will be applied. If this value
	// is less than zero, no log entries will be returned. This can be used to
	// fetch log stream descriptors without fetching any log records.
	LogCount int32 `protobuf:"varint,6,opt,name=log_count,json=logCount,proto3" json:"log_count,omitempty"`
	// If true, allows the range request to return non-contiguous records.
	//
	// A contiguous request (default) will iterate forwards from the supplied
	// Index and stop if either the end of stream is encountered or there is a
	// missing stream index. A NonContiguous request will remove the latter
	// condition.
	//
	// For example, say the log stream consists of:
	// [3, 4, 6, 7]
	//
	// A contiguous request with Index 3 will return: [3, 4], stopping because
	// 5 is missing. A non-contiguous request will return [3, 4, 6, 7].
	NonContiguous        bool                       `protobuf:"varint,7,opt,name=non_contiguous,json=nonContiguous,proto3" json:"non_contiguous,omitempty"`
	GetSignedUrls        *GetRequest_SignURLRequest `protobuf:"bytes,8,opt,name=get_signed_urls,json=getSignedUrls,proto3" json:"get_signed_urls,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{0}
}

func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetRequest.Unmarshal(m, b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return xxx_messageInfo_GetRequest.Size(m)
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *GetRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *GetRequest) GetState() bool {
	if m != nil {
		return m.State
	}
	return false
}

func (m *GetRequest) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetRequest) GetByteCount() int32 {
	if m != nil {
		return m.ByteCount
	}
	return 0
}

func (m *GetRequest) GetLogCount() int32 {
	if m != nil {
		return m.LogCount
	}
	return 0
}

func (m *GetRequest) GetNonContiguous() bool {
	if m != nil {
		return m.NonContiguous
	}
	return false
}

func (m *GetRequest) GetGetSignedUrls() *GetRequest_SignURLRequest {
	if m != nil {
		return m.GetSignedUrls
	}
	return nil
}

// If supplied, the response will contain a SignedUrls message with the
// requested signed URLs. If signed URLs are not supported by the log's
// current storage system, the response message will be empty.
type GetRequest_SignURLRequest struct {
	// The lifetime that the signed URL will be bound to.. The
	Lifetime *duration.Duration `protobuf:"bytes,1,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	// Return a signed URL for the log's RecordIO protobuf data.
	Stream bool `protobuf:"varint,2,opt,name=stream,proto3" json:"stream,omitempty"`
	// Return a signed URL for the log's LogIndex protobuf.
	Index                bool     `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRequest_SignURLRequest) Reset()         { *m = GetRequest_SignURLRequest{} }
func (m *GetRequest_SignURLRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest_SignURLRequest) ProtoMessage()    {}
func (*GetRequest_SignURLRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{0, 0}
}

func (m *GetRequest_SignURLRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetRequest_SignURLRequest.Unmarshal(m, b)
}
func (m *GetRequest_SignURLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetRequest_SignURLRequest.Marshal(b, m, deterministic)
}
func (m *GetRequest_SignURLRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest_SignURLRequest.Merge(m, src)
}
func (m *GetRequest_SignURLRequest) XXX_Size() int {
	return xxx_messageInfo_GetRequest_SignURLRequest.Size(m)
}
func (m *GetRequest_SignURLRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest_SignURLRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest_SignURLRequest proto.InternalMessageInfo

func (m *GetRequest_SignURLRequest) GetLifetime() *duration.Duration {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

func (m *GetRequest_SignURLRequest) GetStream() bool {
	if m != nil {
		return m.Stream
	}
	return false
}

func (m *GetRequest_SignURLRequest) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

// TailRequest is the request structure for the user Tail endpoint. It returns
// the last log in a given log stream at the time of the request.
type TailRequest struct {
	// The request project to request.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// The path of the log stream to get.
	//
	// This can either be a LogDog stream path or the SHA256 hash of a LogDog
	// stream path.
	//
	// Some utilities may find passing around a full LogDog path to be cumbersome
	// due to its length. They can opt to pass around the hash instead and
	// retrieve logs using it.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// If true, requests that the log stream's state is returned.
	State                bool     `protobuf:"varint,3,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TailRequest) Reset()         { *m = TailRequest{} }
func (m *TailRequest) String() string { return proto.CompactTextString(m) }
func (*TailRequest) ProtoMessage()    {}
func (*TailRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{1}
}

func (m *TailRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TailRequest.Unmarshal(m, b)
}
func (m *TailRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TailRequest.Marshal(b, m, deterministic)
}
func (m *TailRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TailRequest.Merge(m, src)
}
func (m *TailRequest) XXX_Size() int {
	return xxx_messageInfo_TailRequest.Size(m)
}
func (m *TailRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TailRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TailRequest proto.InternalMessageInfo

func (m *TailRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *TailRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *TailRequest) GetState() bool {
	if m != nil {
		return m.State
	}
	return false
}

// GetResponse is the response structure for the user Get endpoint.
type GetResponse struct {
	// Project is the project name that these logs belong to.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// The log stream descriptor and state for this stream.
	//
	// It can be requested by setting the request's State field to true. If the
	// Proto field is true, the State's Descriptor field will not be included.
	State *LogStreamState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	// The expanded LogStreamDescriptor protobuf. It is intended for JSON
	// consumption.
	//
	// If the GetRequest's Proto field is false, this will be populated;
	// otherwise, the serialized protobuf will be written to the DescriptorProto
	// field.
	Desc *logpb.LogStreamDescriptor `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	// Log represents the set of retrieved log records.
	Logs []*logpb.LogEntry `protobuf:"bytes,4,rep,name=logs,proto3" json:"logs,omitempty"`
	// An optional signed log entry RecordIO protobuf URL, if requested via
	// "sign_entry_url_lifetime".
	SignedUrls           *GetResponse_SignedUrls `protobuf:"bytes,5,opt,name=signed_urls,json=signedUrls,proto3" json:"signed_urls,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{2}
}

func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetResponse.Unmarshal(m, b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetResponse.Marshal(b, m, deterministic)
}
func (m *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(m, src)
}
func (m *GetResponse) XXX_Size() int {
	return xxx_messageInfo_GetResponse.Size(m)
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

func (m *GetResponse) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *GetResponse) GetState() *LogStreamState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *GetResponse) GetDesc() *logpb.LogStreamDescriptor {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *GetResponse) GetLogs() []*logpb.LogEntry {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *GetResponse) GetSignedUrls() *GetResponse_SignedUrls {
	if m != nil {
		return m.SignedUrls
	}
	return nil
}

// Holds information about the log stream's signed entry URL.
type GetResponse_SignedUrls struct {
	// The time when this signed URL will expire.
	Expiration *timestamp.Timestamp `protobuf:"bytes,1,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// The signed log stream URL, if requested.
	Stream string `protobuf:"bytes,2,opt,name=stream,proto3" json:"stream,omitempty"`
	// The signed log index URL, if requested.
	Index                string   `protobuf:"bytes,3,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetResponse_SignedUrls) Reset()         { *m = GetResponse_SignedUrls{} }
func (m *GetResponse_SignedUrls) String() string { return proto.CompactTextString(m) }
func (*GetResponse_SignedUrls) ProtoMessage()    {}
func (*GetResponse_SignedUrls) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{2, 0}
}

func (m *GetResponse_SignedUrls) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetResponse_SignedUrls.Unmarshal(m, b)
}
func (m *GetResponse_SignedUrls) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetResponse_SignedUrls.Marshal(b, m, deterministic)
}
func (m *GetResponse_SignedUrls) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse_SignedUrls.Merge(m, src)
}
func (m *GetResponse_SignedUrls) XXX_Size() int {
	return xxx_messageInfo_GetResponse_SignedUrls.Size(m)
}
func (m *GetResponse_SignedUrls) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse_SignedUrls.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse_SignedUrls proto.InternalMessageInfo

func (m *GetResponse_SignedUrls) GetExpiration() *timestamp.Timestamp {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *GetResponse_SignedUrls) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *GetResponse_SignedUrls) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

// QueryRequest is the request structure for the user Query endpoint.
type QueryRequest struct {
	// (required) The project to query from.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// (required) The stream query parameter.
	//
	// Paths are of the form "full/path/prefix/+/stream/name", where the
	// "stream/name" portion can contain glob-style "*" and "**" operators.
	//
	// If this is just "full/path/prefix", then the stream/name is assumed to be
	// "**" (meaning all streams).
	//
	// Omitting the full path prefix is an error (no wildcards are permitted).
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// If true, returns that the streams' full state is returned instead of just
	// its Path.
	State bool `protobuf:"varint,3,opt,name=state,proto3" json:"state,omitempty"`
	// If true, causes the requested state to be returned as serialized protobuf
	// data instead of deserialized JSON structures.
	Proto bool `protobuf:"varint,4,opt,name=proto,proto3" json:"proto,omitempty"`
	// Next, if not empty, indicates that this query should continue at the point
	// where the previous query left off.
	Next string `protobuf:"bytes,5,opt,name=next,proto3" json:"next,omitempty"`
	// MaxResults is the maximum number of query results to return.
	//
	// If MaxResults is zero, no upper bound will be indicated. However, the
	// returned result count is still be subject to internal constraints.
	MaxResults int32 `protobuf:"varint,6,opt,name=max_results,json=maxResults,proto3" json:"max_results,omitempty"`
	// ContentType, if not empty, restricts results to streams with the supplied
	// content type.
	ContentType string                         `protobuf:"bytes,10,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	StreamType  *QueryRequest_StreamTypeFilter `protobuf:"bytes,11,opt,name=stream_type,json=streamType,proto3" json:"stream_type,omitempty"`
	// Newer restricts results to streams created after the specified date.
	Newer *timestamp.Timestamp `protobuf:"bytes,12,opt,name=newer,proto3" json:"newer,omitempty"`
	// Older restricts results to streams created before the specified date.
	Older *timestamp.Timestamp `protobuf:"bytes,13,opt,name=older,proto3" json:"older,omitempty"`
	// Tags is the set of tags to constrain the query with.
	//
	// A Tag entry may either be:
	// - A key/value query, in which case the results are constrained by logs
	//   whose tag includes that key/value pair.
	// - A key with an missing (nil) value, in which case the results are
	//   constraints by logs that have that tag key, regardless of its value.
	Tags map[string]string `protobuf:"bytes,15,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Purged restricts the query to streams that have or haven't been purged.
	Purged               QueryRequest_Trinary `protobuf:"varint,16,opt,name=purged,proto3,enum=logdog.QueryRequest_Trinary" json:"purged,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *QueryRequest) Reset()         { *m = QueryRequest{} }
func (m *QueryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()    {}
func (*QueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{3}
}

func (m *QueryRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryRequest.Unmarshal(m, b)
}
func (m *QueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryRequest.Marshal(b, m, deterministic)
}
func (m *QueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRequest.Merge(m, src)
}
func (m *QueryRequest) XXX_Size() int {
	return xxx_messageInfo_QueryRequest.Size(m)
}
func (m *QueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRequest proto.InternalMessageInfo

func (m *QueryRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *QueryRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *QueryRequest) GetState() bool {
	if m != nil {
		return m.State
	}
	return false
}

func (m *QueryRequest) GetProto() bool {
	if m != nil {
		return m.Proto
	}
	return false
}

func (m *QueryRequest) GetNext() string {
	if m != nil {
		return m.Next
	}
	return ""
}

func (m *QueryRequest) GetMaxResults() int32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

func (m *QueryRequest) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *QueryRequest) GetStreamType() *QueryRequest_StreamTypeFilter {
	if m != nil {
		return m.StreamType
	}
	return nil
}

func (m *QueryRequest) GetNewer() *timestamp.Timestamp {
	if m != nil {
		return m.Newer
	}
	return nil
}

func (m *QueryRequest) GetOlder() *timestamp.Timestamp {
	if m != nil {
		return m.Older
	}
	return nil
}

func (m *QueryRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *QueryRequest) GetPurged() QueryRequest_Trinary {
	if m != nil {
		return m.Purged
	}
	return QueryRequest_BOTH
}

// The stream type to filter on.
type QueryRequest_StreamTypeFilter struct {
	// The StreamType value to filter on.
	Value                logpb.StreamType `protobuf:"varint,1,opt,name=value,proto3,enum=logpb.StreamType" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *QueryRequest_StreamTypeFilter) Reset()         { *m = QueryRequest_StreamTypeFilter{} }
func (m *QueryRequest_StreamTypeFilter) String() string { return proto.CompactTextString(m) }
func (*QueryRequest_StreamTypeFilter) ProtoMessage()    {}
func (*QueryRequest_StreamTypeFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{3, 0}
}

func (m *QueryRequest_StreamTypeFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryRequest_StreamTypeFilter.Unmarshal(m, b)
}
func (m *QueryRequest_StreamTypeFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryRequest_StreamTypeFilter.Marshal(b, m, deterministic)
}
func (m *QueryRequest_StreamTypeFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRequest_StreamTypeFilter.Merge(m, src)
}
func (m *QueryRequest_StreamTypeFilter) XXX_Size() int {
	return xxx_messageInfo_QueryRequest_StreamTypeFilter.Size(m)
}
func (m *QueryRequest_StreamTypeFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRequest_StreamTypeFilter.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRequest_StreamTypeFilter proto.InternalMessageInfo

func (m *QueryRequest_StreamTypeFilter) GetValue() logpb.StreamType {
	if m != nil {
		return m.Value
	}
	return logpb.StreamType_TEXT
}

// QueryResponse is the response structure for the user Query endpoint.
type QueryResponse struct {
	// Project is the project name that all responses belong to.
	Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	// The list of streams that were identified as the result of the query.
	Streams []*QueryResponse_Stream `protobuf:"bytes,2,rep,name=streams,proto3" json:"streams,omitempty"`
	// If not empty, indicates that there are more query results available.
	// These results can be requested by repeating the Query request with the
	// same Path field and supplying this value in the Next field.
	Next                 string   `protobuf:"bytes,3,opt,name=next,proto3" json:"next,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryResponse) Reset()         { *m = QueryResponse{} }
func (m *QueryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResponse) ProtoMessage()    {}
func (*QueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{4}
}

func (m *QueryResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryResponse.Unmarshal(m, b)
}
func (m *QueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryResponse.Marshal(b, m, deterministic)
}
func (m *QueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse.Merge(m, src)
}
func (m *QueryResponse) XXX_Size() int {
	return xxx_messageInfo_QueryResponse.Size(m)
}
func (m *QueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse proto.InternalMessageInfo

func (m *QueryResponse) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *QueryResponse) GetStreams() []*QueryResponse_Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

func (m *QueryResponse) GetNext() string {
	if m != nil {
		return m.Next
	}
	return ""
}

// Stream represents a single query response stream.
type QueryResponse_Stream struct {
	// Path is the log stream path.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// State is the log stream descriptor and state for this stream.
	//
	// It can be requested by setting the request's State field to true. If the
	// Proto field is true, the State's Descriptor field will not be included.
	State *LogStreamState `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	// The JSON-packed log stream descriptor protobuf.
	//
	// A Descriptor entry corresponds to the Path with the same index.
	//
	// If the query request's State field is set, the descriptor will be
	// populated. If the Proto field is false, Descriptor will be populated;
	// otherwise, DescriptorProto will be populated with the serialized descriptor
	// protobuf.
	Desc *logpb.LogStreamDescriptor `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty"`
	// The serialized log stream Descriptor protobuf.
	DescProto            []byte   `protobuf:"bytes,4,opt,name=desc_proto,json=descProto,proto3" json:"desc_proto,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryResponse_Stream) Reset()         { *m = QueryResponse_Stream{} }
func (m *QueryResponse_Stream) String() string { return proto.CompactTextString(m) }
func (*QueryResponse_Stream) ProtoMessage()    {}
func (*QueryResponse_Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc34668f0f01b99d, []int{4, 0}
}

func (m *QueryResponse_Stream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryResponse_Stream.Unmarshal(m, b)
}
func (m *QueryResponse_Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryResponse_Stream.Marshal(b, m, deterministic)
}
func (m *QueryResponse_Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse_Stream.Merge(m, src)
}
func (m *QueryResponse_Stream) XXX_Size() int {
	return xxx_messageInfo_QueryResponse_Stream.Size(m)
}
func (m *QueryResponse_Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse_Stream proto.InternalMessageInfo

func (m *QueryResponse_Stream) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *QueryResponse_Stream) GetState() *LogStreamState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *QueryResponse_Stream) GetDesc() *logpb.LogStreamDescriptor {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *QueryResponse_Stream) GetDescProto() []byte {
	if m != nil {
		return m.DescProto
	}
	return nil
}

func init() {
	proto.RegisterEnum("logdog.QueryRequest_Trinary", QueryRequest_Trinary_name, QueryRequest_Trinary_value)
	proto.RegisterType((*GetRequest)(nil), "logdog.GetRequest")
	proto.RegisterType((*GetRequest_SignURLRequest)(nil), "logdog.GetRequest.SignURLRequest")
	proto.RegisterType((*TailRequest)(nil), "logdog.TailRequest")
	proto.RegisterType((*GetResponse)(nil), "logdog.GetResponse")
	proto.RegisterType((*GetResponse_SignedUrls)(nil), "logdog.GetResponse.SignedUrls")
	proto.RegisterType((*QueryRequest)(nil), "logdog.QueryRequest")
	proto.RegisterMapType((map[string]string)(nil), "logdog.QueryRequest.TagsEntry")
	proto.RegisterType((*QueryRequest_StreamTypeFilter)(nil), "logdog.QueryRequest.StreamTypeFilter")
	proto.RegisterType((*QueryResponse)(nil), "logdog.QueryResponse")
	proto.RegisterType((*QueryResponse_Stream)(nil), "logdog.QueryResponse.Stream")
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/logdog/api/endpoints/coordinator/logs/v1/logs.proto", fileDescriptor_fc34668f0f01b99d)
}

var fileDescriptor_fc34668f0f01b99d = []byte{
	// 907 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x92, 0xdb, 0x44,
	0x10, 0x46, 0xb6, 0xfc, 0xd7, 0x5a, 0x7b, 0xcd, 0x10, 0x52, 0x42, 0x90, 0x8d, 0x63, 0x48, 0xe1,
	0x03, 0x25, 0x07, 0x13, 0x7e, 0x2a, 0x1c, 0xa8, 0x22, 0xff, 0xd4, 0x16, 0x21, 0x63, 0xe7, 0xc0,
	0xc9, 0xa5, 0xb5, 0x26, 0x93, 0x01, 0x79, 0x46, 0xcc, 0x8c, 0x16, 0xfb, 0x09, 0x38, 0x70, 0xe2,
	0xc8, 0x85, 0x97, 0xe3, 0x45, 0xa8, 0x99, 0x91, 0x2c, 0x67, 0xe3, 0x62, 0x0f, 0x2c, 0x17, 0x4b,
	0xdd, 0xfd, 0xf5, 0xa8, 0xfb, 0xfb, 0xba, 0xc7, 0xf0, 0x84, 0x8a, 0x78, 0xf5, 0x4a, 0x8a, 0x35,
	0x2b, 0xd6, 0xb1, 0x90, 0x74, 0x9a, 0x15, 0x2b, 0x36, 0xcd, 0x04, 0x4d, 0x05, 0x9d, 0x26, 0x39,
	0x9b, 0x12, 0x9e, 0xe6, 0x82, 0x71, 0xad, 0xa6, 0x2b, 0x21, 0x64, 0xca, 0x78, 0xa2, 0x85, 0x34,
	0x00, 0x35, 0x3d, 0xff, 0xd4, 0x3e, 0xe3, 0x5c, 0x0a, 0x2d, 0x50, 0xdb, 0x25, 0x45, 0x4f, 0xff,
	0xdb, 0x89, 0x4a, 0x27, 0x9a, 0xb8, 0x23, 0xa3, 0xe9, 0x65, 0x47, 0x65, 0x82, 0xe6, 0x67, 0xe6,
	0xb7, 0x4c, 0xb8, 0x49, 0x85, 0xa0, 0x19, 0x99, 0x5a, 0xeb, 0xac, 0x78, 0x39, 0xd5, 0x6c, 0x4d,
	0x94, 0x4e, 0xd6, 0x79, 0x09, 0x38, 0xb9, 0x08, 0x48, 0x0b, 0x99, 0x68, 0x26, 0xb8, 0x8b, 0x8f,
	0x7f, 0x6f, 0x02, 0x3c, 0x26, 0x1a, 0x93, 0x5f, 0x0a, 0xa2, 0x34, 0x0a, 0xa1, 0x93, 0x4b, 0xf1,
	0x13, 0x59, 0xe9, 0xd0, 0x1b, 0x79, 0x93, 0x1e, 0xae, 0x4c, 0x84, 0xc0, 0xcf, 0x13, 0xfd, 0x2a,
	0x6c, 0x58, 0xb7, 0x7d, 0x47, 0xd7, 0xa0, 0x65, 0xab, 0x0f, 0x9b, 0x23, 0x6f, 0xd2, 0xc5, 0xce,
	0x30, 0x5e, 0xc6, 0x53, 0xb2, 0x09, 0xfd, 0x91, 0x37, 0x69, 0x62, 0x67, 0xa0, 0x1b, 0x00, 0x67,
	0x5b, 0x4d, 0x96, 0x2b, 0x51, 0x70, 0x1d, 0xb6, 0x46, 0xde, 0xa4, 0x85, 0x7b, 0xc6, 0x73, 0xdf,
	0x38, 0xd0, 0xfb, 0xd0, 0xcb, 0x04, 0x2d, 0xa3, 0x6d, 0x1b, 0xed, 0x66, 0x82, 0xba, 0xe0, 0x6d,
	0x18, 0x70, 0xc1, 0x97, 0x2b, 0xc1, 0x35, 0xa3, 0x85, 0x28, 0x54, 0xd8, 0xb1, 0x1f, 0xec, 0x73,
	0xc1, 0xef, 0xef, 0x9c, 0xe8, 0x29, 0x1c, 0x53, 0xa2, 0x97, 0x8a, 0x51, 0x4e, 0xd2, 0x65, 0x21,
	0x33, 0x15, 0x76, 0x47, 0xde, 0x24, 0x98, 0xdd, 0x8a, 0x1d, 0x85, 0x71, 0xdd, 0x69, 0x3c, 0x67,
	0x94, 0xbf, 0xc0, 0xa7, 0xa5, 0x89, 0xfb, 0x94, 0xe8, 0xb9, 0x4d, 0x7c, 0x21, 0x33, 0x15, 0x15,
	0x30, 0x78, 0x1d, 0x80, 0x3e, 0x87, 0x6e, 0xc6, 0x5e, 0x12, 0xc3, 0xaf, 0xa5, 0x26, 0x98, 0xbd,
	0x17, 0x3b, 0x6e, 0xe3, 0x8a, 0xdb, 0xf8, 0x41, 0xc9, 0x2d, 0xde, 0x41, 0xd1, 0x75, 0x68, 0x2b,
	0x2d, 0x49, 0xb2, 0xb6, 0xc4, 0x75, 0x71, 0x69, 0xd5, 0x24, 0x95, 0xd4, 0x59, 0x63, 0xfc, 0x1c,
	0x82, 0x45, 0xc2, 0xb2, 0x2b, 0x54, 0x63, 0xfc, 0x77, 0x03, 0x02, 0xdb, 0xb6, 0xca, 0x05, 0x57,
	0xe4, 0x5f, 0xce, 0xfc, 0xa4, 0xca, 0x6f, 0xd8, 0xf6, 0xae, 0x57, 0xa4, 0x9d, 0x0a, 0x3a, 0xb7,
	0x45, 0xcf, 0x4d, 0xb4, 0x52, 0x39, 0x06, 0x3f, 0x25, 0x6a, 0x65, 0x3f, 0x16, 0xcc, 0xa2, 0xd8,
	0x4e, 0x66, 0x8d, 0x7d, 0x40, 0xd4, 0x4a, 0xb2, 0x5c, 0x0b, 0x89, 0x2d, 0x0e, 0x7d, 0x08, 0xbe,
	0x99, 0xf8, 0xd0, 0x1f, 0x35, 0x27, 0xc1, 0xec, 0xb8, 0xc6, 0x3f, 0xe4, 0x5a, 0x6e, 0xb1, 0x0d,
	0xa2, 0x6f, 0x20, 0xd8, 0x57, 0xaf, 0x65, 0xcf, 0x3e, 0x79, 0x4d, 0x3d, 0xd7, 0x46, 0x5c, 0x6b,
	0x85, 0x41, 0xd5, 0xba, 0x9d, 0x03, 0xd4, 0x11, 0x74, 0x0f, 0x80, 0x6c, 0x72, 0xe6, 0x44, 0x29,
	0x55, 0x8b, 0xde, 0x50, 0x6d, 0x51, 0xad, 0x0c, 0xde, 0x43, 0x5f, 0x10, 0xae, 0x77, 0x58, 0xb8,
	0x5e, 0x25, 0xdc, 0x6f, 0x2d, 0x38, 0x7a, 0x5e, 0x10, 0xb9, 0xbd, 0xe2, 0x45, 0xb2, 0x45, 0xda,
	0x45, 0xea, 0x62, 0x67, 0x98, 0x7c, 0x4e, 0x36, 0x6e, 0x85, 0x7a, 0xd8, 0xbe, 0xa3, 0x9b, 0x10,
	0xac, 0x93, 0xcd, 0x52, 0x12, 0x55, 0x64, 0x5a, 0x95, 0xfb, 0x03, 0xeb, 0x64, 0x83, 0x9d, 0x07,
	0xdd, 0x82, 0x23, 0xb3, 0x3d, 0x84, 0xeb, 0xa5, 0xde, 0xe6, 0x24, 0x04, 0x9b, 0x1c, 0x94, 0xbe,
	0xc5, 0x36, 0x27, 0xe8, 0x11, 0x04, 0xae, 0x45, 0x87, 0x08, 0x2c, 0x5b, 0xb7, 0x2b, 0xee, 0xf7,
	0x9b, 0x8b, 0x9d, 0xc4, 0x26, 0xeb, 0x11, 0xcb, 0x34, 0x91, 0x18, 0xd4, 0xce, 0x83, 0xee, 0x40,
	0x8b, 0x93, 0x5f, 0x89, 0x0c, 0x8f, 0x2e, 0xe5, 0xdb, 0x01, 0x4d, 0x86, 0xc8, 0x52, 0x22, 0xc3,
	0xfe, 0xe5, 0x19, 0x16, 0x88, 0x66, 0xe0, 0xeb, 0x84, 0xaa, 0xf0, 0xd8, 0x0e, 0xd3, 0xc9, 0xc1,
	0x22, 0x17, 0x09, 0x55, 0xe5, 0x6c, 0x19, 0x2c, 0xba, 0x0b, 0xed, 0xbc, 0x90, 0x94, 0xa4, 0xe1,
	0x70, 0xe4, 0x4d, 0x06, 0xb3, 0x0f, 0x0e, 0x67, 0x49, 0xc6, 0x13, 0xb9, 0xc5, 0x25, 0x36, 0xfa,
	0x1a, 0x86, 0x17, 0xbb, 0x45, 0x1f, 0x43, 0xeb, 0x3c, 0xc9, 0x0a, 0x77, 0x0f, 0x0c, 0x66, 0x6f,
	0x97, 0xb3, 0x5c, 0xe3, 0xb0, 0x8b, 0x47, 0x5f, 0x42, 0x6f, 0x57, 0x05, 0x1a, 0x42, 0xf3, 0x67,
	0xb2, 0x2d, 0xa7, 0xc1, 0xbc, 0x1a, 0x7d, 0xdd, 0x39, 0x6e, 0x14, 0x9c, 0x71, 0xaf, 0xf1, 0x95,
	0x37, 0xfe, 0x08, 0x3a, 0x65, 0x21, 0xa8, 0x0b, 0xfe, 0xb7, 0xcf, 0x16, 0x4f, 0x86, 0x6f, 0xa1,
	0x0e, 0x34, 0x7f, 0x7c, 0x38, 0x1f, 0x7a, 0xa8, 0x0d, 0x8d, 0xef, 0x9f, 0x0d, 0x1b, 0xdf, 0xf9,
	0xdd, 0xc1, 0xf0, 0x18, 0xf7, 0x2d, 0x4d, 0xcb, 0x73, 0x22, 0x15, 0x13, 0x7c, 0xfc, 0x47, 0x03,
	0xfa, 0x65, 0x47, 0x97, 0x6e, 0xfc, 0x17, 0xd0, 0x71, 0xc2, 0xa9, 0xb0, 0x61, 0x99, 0xbc, 0xc8,
	0x49, 0xb5, 0x6c, 0x16, 0x84, 0x2b, 0xf0, 0x6e, 0x04, 0x9b, 0xf5, 0x08, 0x46, 0x7f, 0x7a, 0xd0,
	0x76, 0xb8, 0xdd, 0x84, 0x7b, 0x7b, 0x13, 0xfe, 0xff, 0x5e, 0x2e, 0x37, 0x00, 0xcc, 0x73, 0x59,
	0xaf, 0xcb, 0x11, 0xee, 0x19, 0xcf, 0x0f, 0xc6, 0x31, 0xfb, 0xcb, 0x03, 0xff, 0xd4, 0xdc, 0x2f,
	0x31, 0x34, 0x1f, 0x13, 0x8d, 0xd0, 0x9b, 0xff, 0x07, 0xd1, 0x3b, 0x07, 0x6e, 0x19, 0x74, 0x07,
	0x7c, 0x73, 0x1f, 0xa3, 0x5d, 0x70, 0xef, 0x76, 0x3e, 0x9c, 0x71, 0x17, 0x5a, 0x96, 0x3b, 0x74,
	0xed, 0xd0, 0x78, 0x45, 0xef, 0x1e, 0x24, 0xf8, 0xac, 0x6d, 0x0b, 0xff, 0xec, 0x9f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xc7, 0x7b, 0x91, 0xa1, 0x9d, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// LogsClient is the client API for Logs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LogsClient interface {
	// Get returns state and log data for a single log stream.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Tail returns the last log in the log stream at the time of the request.
	Tail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Query returns log stream paths that match the requested query.
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
}
type logsPRPCClient struct {
	client *prpc.Client
}

func NewLogsPRPCClient(client *prpc.Client) LogsClient {
	return &logsPRPCClient{client}
}

func (c *logsPRPCClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.client.Call(ctx, "logdog.Logs", "Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logsPRPCClient) Tail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.client.Call(ctx, "logdog.Logs", "Tail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logsPRPCClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.client.Call(ctx, "logdog.Logs", "Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type logsClient struct {
	cc grpc.ClientConnInterface
}

func NewLogsClient(cc grpc.ClientConnInterface) LogsClient {
	return &logsClient{cc}
}

func (c *logsClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/logdog.Logs/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logsClient) Tail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/logdog.Logs/Tail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logsClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, "/logdog.Logs/Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogsServer is the server API for Logs service.
type LogsServer interface {
	// Get returns state and log data for a single log stream.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// Tail returns the last log in the log stream at the time of the request.
	Tail(context.Context, *TailRequest) (*GetResponse, error)
	// Query returns log stream paths that match the requested query.
	Query(context.Context, *QueryRequest) (*QueryResponse, error)
}

// UnimplementedLogsServer can be embedded to have forward compatible implementations.
type UnimplementedLogsServer struct {
}

func (*UnimplementedLogsServer) Get(ctx context.Context, req *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedLogsServer) Tail(ctx context.Context, req *TailRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Tail not implemented")
}
func (*UnimplementedLogsServer) Query(ctx context.Context, req *QueryRequest) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}

func RegisterLogsServer(s prpc.Registrar, srv LogsServer) {
	s.RegisterService(&_Logs_serviceDesc, srv)
}

func _Logs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logdog.Logs/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogsServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logs_Tail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogsServer).Tail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logdog.Logs/Tail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogsServer).Tail(ctx, req.(*TailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Logs_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogsServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/logdog.Logs/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogsServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Logs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "logdog.Logs",
	HandlerType: (*LogsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Logs_Get_Handler,
		},
		{
			MethodName: "Tail",
			Handler:    _Logs_Tail_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _Logs_Query_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/logdog/api/endpoints/coordinator/logs/v1/logs.proto",
}
